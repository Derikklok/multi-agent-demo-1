<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bookstore_mas/ontology.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bookstore_mas/ontology.py" />
              <option name="originalContent" value="from owlready2 import *&#10;from datetime import datetime&#10;import uuid&#10;&#10;ONTO_URI = &quot;http://example.org/bookstore.owl&quot;&#10;onto = get_ontology(ONTO_URI)&#10;&#10;with onto:&#10;    # Core classes&#10;    class Book(Thing): pass&#10;    class Customer(Thing): pass&#10;    class Employee(Thing): pass&#10;&#10;    # Assignment extensions&#10;    class Order(Thing): pass&#10;    class Inventory(Thing): pass&#10;    class LowStockBook(Book): pass  # will be inferred by SWRL when below threshold&#10;&#10;    # Data properties (Functional)&#10;    class hasName(DataProperty, FunctionalProperty): pass&#10;    class hasTitle(DataProperty, FunctionalProperty): pass&#10;    class hasAuthor(DataProperty, FunctionalProperty): pass&#10;    class hasGenre(DataProperty, FunctionalProperty): pass&#10;    class availableQuantity(DataProperty, FunctionalProperty): pass&#10;    class currentQuantity(DataProperty, FunctionalProperty): pass  # for Inventory&#10;    class hasPrice(DataProperty, FunctionalProperty): pass&#10;    class restockThreshold(DataProperty, FunctionalProperty): pass&#10;    class hasQuantity(DataProperty, FunctionalProperty): pass      # for Order quantity&#10;    class hasUnitPrice(DataProperty, FunctionalProperty): pass     # for Order unit price&#10;    class orderTime(DataProperty, FunctionalProperty): pass        # datetime&#10;&#10;    # Object properties&#10;    class borrows(ObjectProperty): pass&#10;    class worksAt(ObjectProperty): pass&#10;    class purchases(ObjectProperty): pass            # Customer -&gt; Book&#10;    class hasBuyer(ObjectProperty, FunctionalProperty): pass  # Order -&gt; Customer&#10;    class hasItem(ObjectProperty, FunctionalProperty): pass   # Order -&gt; Book&#10;    class tracksBook(ObjectProperty, FunctionalProperty): pass # Inventory -&gt; Book&#10;&#10;    # SWRL-like rules&#10;    # If there exists an Order linking a customer and a book, infer purchases(customer, book)&#10;    rule_purchases = Imp()&#10;    rule_purchases.set_as_rule(&quot;Order(?o), hasBuyer(?o, ?c), hasItem(?o, ?b) -&gt; purchases(?c, ?b)&quot;)&#10;&#10;    # Classify a book as LowStockBook when availableQuantity &lt; restockThreshold&#10;    rule_low_stock = Imp()&#10;    rule_low_stock.set_as_rule(&#10;        &quot;Book(?b), availableQuantity(?b, ?q), restockThreshold(?b, ?t), swrlb:lessThan(?q, ?t) -&gt; LowStockBook(?b)&quot;&#10;    )&#10;&#10;&#10;def _first(val, default=None):&#10;    try:&#10;        # Owlready2 properties are list-like; handle both list and scalar&#10;        return val[0] if val else default&#10;    except Exception:&#10;        return val if val is not None else default&#10;&#10;&#10;def get_inventory_for_book(book: onto.Book):&#10;    for inv in onto.Inventory.instances():&#10;        if _first(inv.tracksBook) == book:&#10;            return inv&#10;    return None&#10;&#10;&#10;def create_order(customer: onto.Customer, book: onto.Book, quantity: int = 1):&#10;    &quot;&quot;&quot;Create an Order instance linked to customer and book; also set unit price and timestamp.&quot;&quot;&quot;&#10;    oid = f&quot;order_{uuid.uuid4().hex[:8]}&quot;&#10;    order = onto.Order(oid)&#10;    order.hasBuyer = customer&#10;    order.hasItem = book&#10;    order.hasQuantity = int(quantity)&#10;    unit_price = float(_first(book.hasPrice, 0) or 0)&#10;    order.hasUnitPrice = unit_price&#10;    order.orderTime = datetime.now()&#10;    # Also record direct relation for convenience&#10;    if book not in (customer.purchases or []):&#10;        customer.purchases.append(book)&#10;    return order&#10;&#10;&#10;def run_reasoner_safe():&#10;    &quot;&quot;&quot;Attempt to run a reasoner to compute SWRL inferences; ignore if Java/engine is unavailable.&quot;&quot;&quot;&#10;    try:&#10;        from owlready2 import sync_reasoner_pellet&#10;        sync_reasoner_pellet(infer_property_values=True)&#10;        print(&quot;Reasoner ran successfully (pellet)&quot;)&#10;    except Exception as e:&#10;        try:&#10;            from owlready2 import sync_reasoner&#10;            sync_reasoner()&#10;            print(&quot;Reasoner ran successfully&quot;)&#10;        except Exception:&#10;            print(&quot;Reasoner not available; skipping SWRL inference (this is optional)&quot;)&#10;&#10;&#10;def create_sample_data():&#10;    &quot;&quot;&quot;Initial sample data for simulation&quot;&quot;&quot;&#10;    # Books&#10;    b1 = Book(&quot;book_python&quot;)&#10;    b1.hasTitle = &quot;Python Basics&quot;&#10;    b1.hasAuthor = &quot;Jane Smith&quot;&#10;    b1.hasGenre = &quot;Programming&quot;&#10;    b1.availableQuantity = 2&#10;    b1.hasPrice = 10.0&#10;    b1.restockThreshold = 1&#10;&#10;    b2 = Book(&quot;book_hp&quot;)&#10;    b2.hasTitle = &quot;Harry Potter&quot;&#10;    b2.hasAuthor = &quot;J.K. Rowling&quot;&#10;    b2.hasGenre = &quot;Fantasy&quot;&#10;    b2.availableQuantity = 1&#10;    b2.hasPrice = 12.5&#10;    b2.restockThreshold = 1&#10;&#10;    # Inventory for each book&#10;    i1 = Inventory(&quot;inv_python&quot;)&#10;    i1.tracksBook = b1&#10;    i1.currentQuantity = _first(b1.availableQuantity, 0) or 0&#10;&#10;    i2 = Inventory(&quot;inv_hp&quot;)&#10;    i2.tracksBook = b2&#10;    i2.currentQuantity = _first(b2.availableQuantity, 0) or 0&#10;&#10;    # Customers&#10;    c1 = Customer(&quot;customer_alice&quot;)&#10;    c1.hasName = &quot;Alice&quot;&#10;&#10;    c2 = Customer(&quot;customer_bob&quot;)&#10;    c2.hasName = &quot;Bob&quot;&#10;&#10;    # Employees&#10;    e1 = Employee(&quot;employee_emma&quot;)&#10;    e1.hasName = &quot;Emma&quot;&#10;&#10;&#10;def list_inventory():&#10;    for b in onto.Book.instances():&#10;        qty = int(_first(b.availableQuantity, 0) or 0)&#10;        title = _first(b.hasTitle, b.name)&#10;        print(f&quot;- {title}: qty={qty}&quot;)&#10;&#10;&#10;def list_purchases():&#10;    for c in onto.Customer.instances():&#10;        name = _first(c.hasName, c.name)&#10;        items = [ _first(b.hasTitle, b.name) for b in (c.purchases or []) ]&#10;        print(f&quot;Customer {name} purchases: {items}&quot;)&#10;" />
              <option name="updatedContent" value="from owlready2 import *&#10;from datetime import datetime&#10;import uuid&#10;&#10;ONTO_URI = &quot;http://example.org/bookstore.owl&quot;&#10;onto = get_ontology(ONTO_URI)&#10;&#10;with onto:&#10;    # Core classes&#10;    class Book(Thing): pass&#10;    class Customer(Thing): pass&#10;    class Employee(Thing): pass&#10;&#10;    # Assignment extensions&#10;    class Order(Thing): pass&#10;    class Inventory(Thing): pass&#10;    class LowStockBook(Book): pass  # will be inferred by SWRL when below threshold&#10;&#10;    # Data properties (Functional)&#10;    class hasName(DataProperty, FunctionalProperty): pass&#10;    class hasTitle(DataProperty, FunctionalProperty): pass&#10;    class hasAuthor(DataProperty, FunctionalProperty): pass&#10;    class hasGenre(DataProperty, FunctionalProperty): pass&#10;    class availableQuantity(DataProperty, FunctionalProperty): pass&#10;    class currentQuantity(DataProperty, FunctionalProperty): pass  # for Inventory&#10;    class hasPrice(DataProperty, FunctionalProperty): pass&#10;    class restockThreshold(DataProperty, FunctionalProperty): pass&#10;    class hasQuantity(DataProperty, FunctionalProperty): pass      # for Order quantity&#10;    class hasUnitPrice(DataProperty, FunctionalProperty): pass     # for Order unit price&#10;    class orderTime(DataProperty, FunctionalProperty): pass        # datetime&#10;&#10;    # Object properties&#10;    class borrows(ObjectProperty): pass&#10;    class worksAt(ObjectProperty): pass&#10;    class purchases(ObjectProperty): pass            # Customer -&gt; Book&#10;    class hasBuyer(ObjectProperty, FunctionalProperty): pass  # Order -&gt; Customer&#10;    class hasItem(ObjectProperty, FunctionalProperty): pass   # Order -&gt; Book&#10;    class tracksBook(ObjectProperty, FunctionalProperty): pass # Inventory -&gt; Book&#10;&#10;    # Register SWRL namespaces so built-ins like swrlb:lessThan resolve&#10;    swrl  = onto.world.get_namespace(&quot;http://www.w3.org/2003/11/swrl#&quot;)   # noqa: F841&#10;    swrlb = onto.world.get_namespace(&quot;http://www.w3.org/2003/11/swrlb#&quot;)  # noqa: F841&#10;&#10;    # SWRL-like rules&#10;    # If there exists an Order linking a customer and a book, infer purchases(customer, book)&#10;    rule_purchases = Imp()&#10;    rule_purchases.set_as_rule(&quot;Order(?o), hasBuyer(?o, ?c), hasItem(?o, ?b) -&gt; purchases(?c, ?b)&quot;)&#10;&#10;    # Classify a book as LowStockBook when availableQuantity &lt; restockThreshold&#10;    rule_low_stock = Imp()&#10;    rule_low_stock.set_as_rule(&#10;        &quot;Book(?b), availableQuantity(?b, ?q), restockThreshold(?b, ?t), swrlb:lessThan(?q, ?t) -&gt; LowStockBook(?b)&quot;&#10;    )&#10;&#10;&#10;def _first(val, default=None):&#10;    try:&#10;        # Owlready2 properties are list-like; handle both list and scalar&#10;        return val[0] if val else default&#10;    except Exception:&#10;        return val if val is not None else default&#10;&#10;&#10;def get_inventory_for_book(book: onto.Book):&#10;    for inv in onto.Inventory.instances():&#10;        if _first(inv.tracksBook) == book:&#10;            return inv&#10;    return None&#10;&#10;&#10;def create_order(customer: onto.Customer, book: onto.Book, quantity: int = 1):&#10;    &quot;&quot;&quot;Create an Order instance linked to customer and book; also set unit price and timestamp.&quot;&quot;&quot;&#10;    oid = f&quot;order_{uuid.uuid4().hex[:8]}&quot;&#10;    order = onto.Order(oid)&#10;    order.hasBuyer = customer&#10;    order.hasItem = book&#10;    order.hasQuantity = int(quantity)&#10;    unit_price = float(_first(book.hasPrice, 0) or 0)&#10;    order.hasUnitPrice = unit_price&#10;    order.orderTime = datetime.now()&#10;    # Also record direct relation for convenience&#10;    if book not in (customer.purchases or []):&#10;        customer.purchases.append(book)&#10;    return order&#10;&#10;&#10;def run_reasoner_safe():&#10;    &quot;&quot;&quot;Attempt to run a reasoner to compute SWRL inferences; ignore if Java/engine is unavailable.&quot;&quot;&quot;&#10;    try:&#10;        from owlready2 import sync_reasoner_pellet&#10;        sync_reasoner_pellet(infer_property_values=True)&#10;        print(&quot;Reasoner ran successfully (pellet)&quot;)&#10;    except Exception as e:&#10;        try:&#10;            from owlready2 import sync_reasoner&#10;            sync_reasoner()&#10;            print(&quot;Reasoner ran successfully&quot;)&#10;        except Exception:&#10;            print(&quot;Reasoner not available; skipping SWRL inference (this is optional)&quot;)&#10;&#10;&#10;def create_sample_data():&#10;    &quot;&quot;&quot;Initial sample data for simulation&quot;&quot;&quot;&#10;    # Books&#10;    b1 = Book(&quot;book_python&quot;)&#10;    b1.hasTitle = &quot;Python Basics&quot;&#10;    b1.hasAuthor = &quot;Jane Smith&quot;&#10;    b1.hasGenre = &quot;Programming&quot;&#10;    b1.availableQuantity = 2&#10;    b1.hasPrice = 10.0&#10;    b1.restockThreshold = 1&#10;&#10;    b2 = Book(&quot;book_hp&quot;)&#10;    b2.hasTitle = &quot;Harry Potter&quot;&#10;    b2.hasAuthor = &quot;J.K. Rowling&quot;&#10;    b2.hasGenre = &quot;Fantasy&quot;&#10;    b2.availableQuantity = 1&#10;    b2.hasPrice = 12.5&#10;    b2.restockThreshold = 1&#10;&#10;    # Inventory for each book&#10;    i1 = Inventory(&quot;inv_python&quot;)&#10;    i1.tracksBook = b1&#10;    i1.currentQuantity = _first(b1.availableQuantity, 0) or 0&#10;&#10;    i2 = Inventory(&quot;inv_hp&quot;)&#10;    i2.tracksBook = b2&#10;    i2.currentQuantity = _first(b2.availableQuantity, 0) or 0&#10;&#10;    # Customers&#10;    c1 = Customer(&quot;customer_alice&quot;)&#10;    c1.hasName = &quot;Alice&quot;&#10;&#10;    c2 = Customer(&quot;customer_bob&quot;)&#10;    c2.hasName = &quot;Bob&quot;&#10;&#10;    # Employees&#10;    e1 = Employee(&quot;employee_emma&quot;)&#10;    e1.hasName = &quot;Emma&quot;&#10;&#10;&#10;def list_inventory():&#10;    for b in onto.Book.instances():&#10;        qty = int(_first(b.availableQuantity, 0) or 0)&#10;        title = _first(b.hasTitle, b.name)&#10;        print(f&quot;- {title}: qty={qty}&quot;)&#10;&#10;&#10;def list_purchases():&#10;    for c in onto.Customer.instances():&#10;        name = _first(c.hasName, c.name)&#10;        items = [ _first(b.hasTitle, b.name) for b in (c.purchases or []) ]&#10;        print(f&quot;Customer {name} purchases: {items}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>