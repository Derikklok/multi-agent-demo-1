<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/streamlit_app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/streamlit_app.py" />
              <option name="originalContent" value="import streamlit as st&#10;import io, csv&#10;import pandas as pd&#10;import altair as alt&#10;from owlready2 import destroy_entity&#10;from bookstore_mas.model import LibraryModel&#10;from bookstore_mas.ontology import onto, _first, reset_ontology, run_reasoner_safe, get_inventory_for_book&#10;&#10;# ----- Helpers -----&#10;&#10;def inventory_rows():&#10;    rows = []&#10;    for b in onto.Book.instances():&#10;        title = _first(b.hasTitle, b.name)&#10;        qty = int(_first(b.availableQuantity, 0) or 0)&#10;        thr = int(_first(b.restockThreshold, 0) or 0)&#10;        if qty &lt; thr:&#10;            state = &quot;Low&quot;&#10;        elif qty == thr:&#10;            state = &quot;At threshold&quot;&#10;        else:&#10;            state = &quot;OK&quot;&#10;        rows.append({&#10;            &quot;Title&quot;: title,&#10;            &quot;Author&quot;: _first(b.hasAuthor, &quot;&quot;),&#10;            &quot;Genre&quot;: _first(b.hasGenre, &quot;&quot;),&#10;            &quot;Qty&quot;: qty,&#10;            &quot;Threshold&quot;: thr,&#10;            &quot;State&quot;: state,&#10;            &quot;Price&quot;: float(_first(b.hasPrice, 0) or 0),&#10;        })&#10;    return rows&#10;&#10;&#10;def orders_rows():&#10;    rows = []&#10;    for o in onto.Order.instances():&#10;        rows.append({&#10;            &quot;Order ID&quot;: o.name,&#10;            &quot;Buyer&quot;: _first(_first(o.hasBuyer).hasName, _first(o.hasBuyer).name) if _first(o.hasBuyer) else &quot;&quot;,&#10;            &quot;Item&quot;: _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;,&#10;            &quot;Qty&quot;: int(_first(o.hasQuantity, 0) or 0),&#10;            &quot;Unit Price&quot;: float(_first(o.hasUnitPrice, 0) or 0),&#10;            &quot;Time&quot;: str(_first(o.orderTime, &quot;&quot;)),&#10;        })&#10;    return rows&#10;&#10;&#10;def low_stock_fallback(restock_default: int):&#10;    lows = []&#10;    for b in onto.Book.instances():&#10;        q = int(_first(b.availableQuantity, 0) or 0)&#10;        t = int(_first(b.restockThreshold, restock_default) or restock_default)&#10;        if q &lt; t:&#10;            lows.append(_first(b.hasTitle, b.name))&#10;    return lows&#10;&#10;&#10;def record_histories():&#10;    &quot;&quot;&quot;Record inventory quantities, thresholds, new purchases, and new UI events for the current step.&quot;&quot;&quot;&#10;    step = st.session_state.model.current_step&#10;    # Inventory history per book&#10;    for b in onto.Book.instances():&#10;        st.session_state.inv_history.append({&#10;            &quot;step&quot;: step,&#10;            &quot;Title&quot;: _first(b.hasTitle, b.name),&#10;            &quot;Qty&quot;: int(_first(b.availableQuantity, 0) or 0),&#10;            &quot;Threshold&quot;: int(_first(b.restockThreshold, st.session_state.restock_threshold) or st.session_state.restock_threshold),&#10;        })&#10;    # New orders detected in this step&#10;    current_ids = {o.name for o in onto.Order.instances()}&#10;    new_ids = current_ids - st.session_state.last_order_ids&#10;    if new_ids:&#10;        counts = {}&#10;        for oid in new_ids:&#10;            o = onto.search_one(iri=f&quot;*{oid}&quot;) or next((x for x in onto.Order.instances() if x.name == oid), None)&#10;            if not o:  # safety&#10;                continue&#10;            title = _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;&#10;            counts[title] = counts.get(title, 0) + int(_first(o.hasQuantity, 0) or 0)&#10;        for title, cnt in counts.items():&#10;            st.session_state.purchases_history.append({&#10;                &quot;step&quot;: step,&#10;                &quot;Title&quot;: title,&#10;                &quot;Count&quot;: cnt,&#10;            })&#10;    st.session_state.last_order_ids = current_ids&#10;    # Capture new UI events from the model&#10;    evts = st.session_state.model.ui_events&#10;    new_events = evts[st.session_state.events_seen:]&#10;    st.session_state.events_seen = len(evts)&#10;    if new_events:&#10;        st.session_state.event_feed.extend(new_events)&#10;&#10;&#10;def event_badge(evt_type: str) -&gt; str:&#10;    colors = {&#10;        &quot;purchase&quot;: &quot;#2563eb&quot;,        # blue&#10;        &quot;low_stock_trigger&quot;: &quot;#f59e0b&quot;, # amber&#10;        &quot;restock&quot;: &quot;#16a34a&quot;,         # green&#10;        &quot;out_of_stock&quot;: &quot;#dc2626&quot;,    # red&#10;    }&#10;    label = {&#10;        &quot;purchase&quot;: &quot;Purchase&quot;,&#10;        &quot;low_stock_trigger&quot;: &quot;Low stock&quot;,&#10;        &quot;restock&quot;: &quot;Restock&quot;,&#10;        &quot;out_of_stock&quot;: &quot;Out of stock&quot;,&#10;    }.get(evt_type, evt_type)&#10;    color = colors.get(evt_type, &quot;#6b7280&quot;)&#10;    return f'&lt;span style=&quot;background:{color};color:white;padding:2px 8px;border-radius:999px;font-size:12px;&quot;&gt;{label}&lt;/span&gt;'&#10;&#10;&#10;def render_event(evt: dict) -&gt; str:&#10;    t = evt.get(&quot;type&quot;)&#10;    step = evt.get(&quot;step&quot;)&#10;    badge = event_badge(t)&#10;    if t == &quot;purchase&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('customer')} bought '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' (qty {evt.get('qty_before')}→{evt.get('qty_after')}, thr {evt.get('threshold')})&quot;&#10;    if t == &quot;low_stock_trigger&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' fell below threshold (qty {evt.get('qty')}, thr {evt.get('threshold')}) — restock requested&quot;&#10;    if t == &quot;restock&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('employee')} restocked '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' (+{evt.get('added')}, {evt.get('qty_before')}→{evt.get('qty_after')})&quot;&#10;    if t == &quot;out_of_stock&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('customer')} tried to buy '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' but stock was {evt.get('qty')}&quot;&#10;    return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;&quot;&#10;&#10;&#10;# ----- App state -----&#10;&#10;if &quot;restock_threshold&quot; not in st.session_state:&#10;    st.session_state.restock_threshold = 1&#10;if &quot;restock_amount&quot; not in st.session_state:&#10;    st.session_state.restock_amount = 3&#10;if &quot;model&quot; not in st.session_state:&#10;    reset_ontology()&#10;    st.session_state.model = LibraryModel(&#10;        restock_threshold=st.session_state.restock_threshold,&#10;        restock_amount=st.session_state.restock_amount,&#10;    )&#10;    st.session_state.steps = 0&#10;    st.session_state.inv_history = []&#10;    st.session_state.purchases_history = []&#10;    st.session_state.last_order_ids = set()&#10;    st.session_state.event_feed = []&#10;    st.session_state.events_seen = 0&#10;&#10;# ----- UI -----&#10;&#10;st.set_page_config(page_title=&quot;Bookstore MAS&quot;, layout=&quot;wide&quot;)&#10;st.title(&quot;Bookstore Management System - MAS + Ontology&quot;)&#10;&#10;with st.expander(&quot;Setup: define inventory and participants&quot;, expanded=False):&#10;    # Add book form&#10;    st.subheader(&quot;Books&quot;)&#10;    with st.form(&quot;add_book_form&quot;, clear_on_submit=True):&#10;        colA, colB, colC = st.columns([2,2,1])&#10;        with colA:&#10;            in_title = st.text_input(&quot;Title&quot;, placeholder=&quot;e.g., Python Basics&quot;)&#10;            in_author = st.text_input(&quot;Author&quot;, placeholder=&quot;e.g., Jane Smith&quot;)&#10;            in_genre = st.text_input(&quot;Genre&quot;, placeholder=&quot;e.g., Programming&quot;)&#10;        with colB:&#10;            in_price = st.number_input(&quot;Price&quot;, min_value=0.0, step=0.5, value=10.0)&#10;            in_qty = st.number_input(&quot;Quantity&quot;, min_value=0, step=1, value=1)&#10;            in_thr = st.number_input(&quot;Restock threshold&quot;, min_value=0, step=1, value=1)&#10;        submitted = st.form_submit_button(&quot;Add book&quot;)&#10;        if submitted:&#10;            title = in_title.strip()&#10;            if not title:&#10;                st.warning(&quot;Please enter a title&quot;)&#10;            else:&#10;                # Build a safe unique ID&#10;                base = ''.join(ch.lower() if ch.isalnum() else '_' for ch in title).strip('_')&#10;                if not base:&#10;                    base = 'book'&#10;                bid = f&quot;book_{base}&quot;&#10;                # ensure uniqueness&#10;                existing = {b.name for b in onto.Book.instances()}&#10;                suffix = 1&#10;                new_id = bid&#10;                while new_id in existing:&#10;                    suffix += 1&#10;                    new_id = f&quot;{bid}_{suffix}&quot;&#10;                b = onto.Book(new_id)&#10;                b.hasTitle = title&#10;                if in_author:&#10;                    b.hasAuthor = in_author&#10;                if in_genre:&#10;                    b.hasGenre = in_genre&#10;                b.hasPrice = float(in_price)&#10;                b.availableQuantity = int(in_qty)&#10;                b.restockThreshold = int(in_thr)&#10;                inv = onto.Inventory(f&quot;inv_{new_id}&quot;)&#10;                inv.tracksBook = b&#10;                inv.currentQuantity = int(in_qty)&#10;                st.success(f&quot;Added book '{title}' (qty {int(in_qty)}, thr {int(in_thr)})&quot;)&#10;    # Existing books &amp; delete&#10;    books_df = pd.DataFrame([{ 'ID': b.name, 'Title': _first(b.hasTitle,b.name)} for b in onto.Book.instances()])&#10;    if not books_df.empty:&#10;        sel = st.multiselect(&quot;Select books to delete&quot;, options=books_df['Title'].tolist())&#10;        if st.button(&quot;Delete selected books&quot;):&#10;            del_count = 0&#10;            for b in list(onto.Book.instances()):&#10;                if _first(b.hasTitle, b.name) in sel:&#10;                    # delete inventory first, then book&#10;                    inv = get_inventory_for_book(b)&#10;                    if inv is not None:&#10;                        destroy_entity(inv)&#10;                    destroy_entity(b)&#10;                    del_count += 1&#10;            st.success(f&quot;Deleted {del_count} book(s)&quot;)&#10;    else:&#10;        st.info(&quot;No books yet.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    # Customers&#10;    st.subheader(&quot;Customers&quot;)&#10;    col1, col2 = st.columns([2,1])&#10;    with col1:&#10;        cust_name = st.text_input(&quot;New customer name&quot;, key=&quot;cust_name&quot;)&#10;    with col2:&#10;        if st.button(&quot;Add customer&quot;):&#10;            if not cust_name.strip():&#10;                st.warning(&quot;Enter a name&quot;)&#10;            else:&#10;                cname = cust_name.strip()&#10;                cid = f&quot;customer_{''.join(ch.lower() if ch.isalnum() else '_' for ch in cname).strip('_') or 'c'}&quot;&#10;                # ensure uniqueness&#10;                exists = {c.name for c in onto.Customer.instances()}&#10;                i=1; nid=cid&#10;                while nid in exists:&#10;                    i+=1; nid=f&quot;{cid}_{i}&quot;&#10;                c = onto.Customer(nid)&#10;                c.hasName = cname&#10;                st.success(f&quot;Added customer '{cname}'&quot;)&#10;    custs = [ _first(c.hasName, c.name) for c in onto.Customer.instances() ]&#10;    if custs:&#10;        del_custs = st.multiselect(&quot;Delete customers&quot;, options=custs, key=&quot;del_custs&quot;)&#10;        if st.button(&quot;Delete selected customers&quot;):&#10;            d=0&#10;            for c in list(onto.Customer.instances()):&#10;                if _first(c.hasName, c.name) in del_custs:&#10;                    destroy_entity(c); d+=1&#10;            st.success(f&quot;Deleted {d} customer(s)&quot;)&#10;    else:&#10;        st.caption(&quot;No customers yet.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    # Employees&#10;    st.subheader(&quot;Employees&quot;)&#10;    col3, col4 = st.columns([2,1])&#10;    with col3:&#10;        emp_name = st.text_input(&quot;New employee name&quot;, key=&quot;emp_name&quot;)&#10;    with col4:&#10;        if st.button(&quot;Add employee&quot;):&#10;            if not emp_name.strip():&#10;                st.warning(&quot;Enter a name&quot;)&#10;            else:&#10;                ename = emp_name.strip()&#10;                eid = f&quot;employee_{''.join(ch.lower() if ch.isalnum() else '_' for ch in ename).strip('_') or 'e'}&quot;&#10;                exists = {e.name for e in onto.Employee.instances()}&#10;                i=1; nid=eid&#10;                while nid in exists:&#10;                    i+=1; nid=f&quot;{eid}_{i}&quot;&#10;                e = onto.Employee(nid)&#10;                e.hasName = ename&#10;                st.success(f&quot;Added employee '{ename}'&quot;)&#10;    emps = [ _first(e.hasName, e.name) for e in onto.Employee.instances() ]&#10;    if emps:&#10;        del_emps = st.multiselect(&quot;Delete employees&quot;, options=emps, key=&quot;del_emps&quot;)&#10;        if st.button(&quot;Delete selected employees&quot;):&#10;            d=0&#10;            for e in list(onto.Employee.instances()):&#10;                if _first(e.hasName, e.name) in del_emps:&#10;                    destroy_entity(e); d+=1&#10;            st.success(f&quot;Deleted {d} employee(s)&quot;)&#10;    else:&#10;        st.caption(&quot;No employees yet.&quot;)&#10;&#10;with st.sidebar:&#10;    st.header(&quot;Controls&quot;)&#10;    rt = st.number_input(&quot;Restock threshold&quot;, min_value=0, max_value=100, value=st.session_state.restock_threshold, step=1)&#10;    ra = st.number_input(&quot;Restock amount&quot;, min_value=0, max_value=100, value=st.session_state.restock_amount, step=1)&#10;    colA, colB = st.columns(2)&#10;    with colA:&#10;        reset_keep = st.button(&quot;Reset simulation\n(keep data)&quot;)&#10;    with colB:&#10;        reset_sample = st.button(&quot;Load sample\n(reset all)&quot;)&#10;&#10;    if reset_keep:&#10;        st.session_state.restock_threshold = int(rt)&#10;        st.session_state.restock_amount = int(ra)&#10;        st.session_state.model = LibraryModel(&#10;            restock_threshold=st.session_state.restock_threshold,&#10;            restock_amount=st.session_state.restock_amount,&#10;        )&#10;        st.session_state.steps = 0&#10;        st.session_state.inv_history = []&#10;        st.session_state.purchases_history = []&#10;        st.session_state.last_order_ids = set()&#10;        st.session_state.event_feed = []&#10;        st.session_state.events_seen = 0&#10;        st.success(&quot;Simulation reset (kept current data).&quot;)&#10;&#10;    if reset_sample:&#10;        st.session_state.restock_threshold = int(rt)&#10;        st.session_state.restock_amount = int(ra)&#10;        reset_ontology()&#10;        st.session_state.model = LibraryModel(&#10;            restock_threshold=st.session_state.restock_threshold,&#10;            restock_amount=st.session_state.restock_amount,&#10;        )&#10;        st.session_state.steps = 0&#10;        st.session_state.inv_history = []&#10;        st.session_state.purchases_history = []&#10;        st.session_state.last_order_ids = set()&#10;        st.session_state.event_feed = []&#10;        st.session_state.events_seen = 0&#10;        st.success(&quot;Loaded sample data and reset simulation.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    step_once = st.button(&quot;Step once&quot;)&#10;    step_n = st.number_input(&quot;Run N steps&quot;, min_value=1, max_value=1000, value=10, step=1)&#10;    run_n = st.button(&quot;Run N steps ▶&quot;)&#10;    st.markdown(&quot;---&quot;)&#10;    if st.button(&quot;Run reasoner (SWRL)&quot;):&#10;        run_reasoner_safe()&#10;        st.toast(&quot;Reasoner executed (see terminal logs for details)&quot;)&#10;&#10;# Step controls&#10;if step_once:&#10;    st.session_state.model.step()&#10;    st.session_state.steps += 1&#10;    record_histories()&#10;if run_n:&#10;    for _ in range(int(step_n)):&#10;        st.session_state.model.step()&#10;        st.session_state.steps += 1&#10;        record_histories()&#10;&#10;# Summary metrics&#10;col1, col2, col3 = st.columns(3)&#10;col1.metric(&quot;Steps&quot;, st.session_state.steps)&#10;col2.metric(&quot;Current step (model)&quot;, st.session_state.model.current_step)&#10;col3.metric(&quot;Restock threshold&quot;, st.session_state.restock_threshold)&#10;&#10;# Data + Exports&#10;left, right = st.columns(2)&#10;with left:&#10;    st.subheader(&quot;Inventory&quot;)&#10;    inv_df = pd.DataFrame(inventory_rows())&#10;    st.dataframe(inv_df, use_container_width=True)&#10;    # Export inventory CSV&#10;    inv_buf = io.StringIO()&#10;    writer = csv.DictWriter(inv_buf, fieldnames=list(inv_df.columns))&#10;    writer.writeheader()&#10;    for row in inv_df.to_dict(orient=&quot;records&quot;):&#10;        writer.writerow(row)&#10;    st.download_button(&#10;        label=&quot;Download Inventory CSV&quot;,&#10;        data=inv_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;inventory.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;    lows = low_stock_fallback(st.session_state.restock_threshold)&#10;    st.caption(f&quot;Low-stock (fallback): {lows if lows else 'None'}&quot;)&#10;&#10;with right:&#10;    st.subheader(&quot;Orders&quot;)&#10;    orders_df = pd.DataFrame(orders_rows())&#10;    st.dataframe(orders_df, use_container_width=True)&#10;    # Export orders CSV&#10;    ord_buf = io.StringIO()&#10;    if not orders_df.empty:&#10;        writer = csv.DictWriter(ord_buf, fieldnames=list(orders_df.columns))&#10;        writer.writeheader()&#10;        for row in orders_df.to_dict(orient=&quot;records&quot;):&#10;            writer.writerow(row)&#10;    else:&#10;        ord_buf.write(&quot;Order ID,Buyer,Item,Qty,Unit Price,Time\n&quot;)&#10;    st.download_button(&#10;        label=&quot;Download Orders CSV&quot;,&#10;        data=ord_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;orders.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;&#10;# Charts&#10;st.subheader(&quot;Charts&quot;)&#10;chart_left, chart_right = st.columns(2)&#10;with chart_left:&#10;    st.caption(&quot;Current stock vs threshold&quot;)&#10;    if not inv_df.empty:&#10;        inv_df_chart = inv_df.copy()&#10;        def state_color(state: str) -&gt; str:&#10;            return {&quot;Low&quot;: &quot;#dc2626&quot;, &quot;At threshold&quot;: &quot;#f59e0b&quot;, &quot;OK&quot;: &quot;#16a34a&quot;}.get(state, &quot;#6b7280&quot;)&#10;        inv_df_chart[&quot;Color&quot;] = inv_df_chart[&quot;State&quot;].map(state_color)&#10;        bar = alt.Chart(inv_df_chart).mark_bar().encode(&#10;            x=alt.X(&quot;Title:N&quot;, sort=None),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;State:N&quot;, scale=alt.Scale(domain=[&quot;Low&quot;,&quot;At threshold&quot;,&quot;OK&quot;], range=[&quot;#dc2626&quot;,&quot;#f59e0b&quot;,&quot;#16a34a&quot;])),&#10;            tooltip=[&quot;Title&quot;,&quot;Qty&quot;,&quot;Threshold&quot;,&quot;State&quot;,&quot;Price&quot;],&#10;        )&#10;        # Threshold rule per bar is not trivial; show as points overlayed for clarity&#10;        thr_points = alt.Chart(inv_df_chart).mark_point(shape=&quot;triangle-down&quot;, size=120, color=&quot;#f59e0b&quot;).encode(&#10;            x=alt.X(&quot;Title:N&quot;), y=alt.Y(&quot;Threshold:Q&quot;), tooltip=[&quot;Title&quot;,&quot;Threshold&quot;],&#10;        )&#10;        st.altair_chart((bar + thr_points), use_container_width=True)&#10;    else:&#10;        st.info(&quot;No inventory to chart.&quot;)&#10;&#10;with chart_right:&#10;    st.caption(&quot;Inventory over steps vs threshold&quot;)&#10;    inv_hist_df = pd.DataFrame(st.session_state.get(&quot;inv_history&quot;, []))&#10;    if not inv_hist_df.empty:&#10;        qty_line = alt.Chart(inv_hist_df).mark_line(point=True, color=&quot;#2563eb&quot;).encode(&#10;            x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;Title:N&quot;, legend=alt.Legend(title=&quot;Book&quot;)),&#10;            tooltip=[&quot;step:Q&quot;,&quot;Title:N&quot;,&quot;Qty:Q&quot;,&quot;Threshold:Q&quot;],&#10;        )&#10;        thr_line = alt.Chart(inv_hist_df).mark_line(strokeDash=[6,4], color=&quot;#f59e0b&quot;).encode(&#10;            x=alt.X(&quot;step:Q&quot;), y=alt.Y(&quot;Threshold:Q&quot;), color=alt.Color(&quot;Title:N&quot;, legend=None),&#10;        )&#10;        st.altair_chart(qty_line + thr_line, use_container_width=True)&#10;    else:&#10;        st.info(&quot;Step the simulation to build the time series.&quot;)&#10;&#10;st.subheader(&quot;Purchases over time&quot;)&#10;p_hist_df = pd.DataFrame(st.session_state.get(&quot;purchases_history&quot;, []))&#10;if not p_hist_df.empty:&#10;    bars = alt.Chart(p_hist_df).mark_bar().encode(&#10;        x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;        y=alt.Y(&quot;Count:Q&quot;, title=&quot;Purchases&quot;),&#10;        color=alt.Color(&quot;Title:N&quot;, title=&quot;Book&quot;),&#10;        tooltip=[&quot;step:Q&quot;, &quot;Title:N&quot;, &quot;Count:Q&quot;],&#10;    )&#10;    st.altair_chart(bars, use_container_width=True)&#10;else:&#10;    st.info(&quot;No purchases recorded yet. Step the simulation to generate data.&quot;)&#10;&#10;# Purchases summary&#10;st.subheader(&quot;Purchases by customer&quot;)&#10;rows = []&#10;for c in onto.Customer.instances():&#10;    rows.append({&#10;        &quot;Customer&quot;: _first(c.hasName, c.name),&#10;        &quot;Purchases&quot;: &quot;, &quot;.join(_first(b.hasTitle, b.name) for b in (c.purchases or [])),&#10;    })&#10;st.table(rows)&#10;&#10;# Event timeline&#10;st.subheader(&quot;Event timeline&quot;)&#10;with st.container(border=True):&#10;    if st.session_state.event_feed:&#10;        for evt in reversed(st.session_state.event_feed[-30:]):  # show last 30 events&#10;            st.markdown(render_event(evt), unsafe_allow_html=True)&#10;    else:&#10;        st.info(&quot;No events yet. Step the simulation to see purchases, low-stock triggers, and restocks.&quot;)&#10;&#10;# Legend&#10;with st.expander(&quot;Legend: colors and thresholds&quot;):&#10;    st.markdown(&#10;        &quot;- State colors: &lt;span style='color:#16a34a;'&gt;OK&lt;/span&gt;, &lt;span style='color:#f59e0b;'&gt;At threshold&lt;/span&gt;, &lt;span style='color:#dc2626;'&gt;Low&lt;/span&gt;&lt;br&gt;&quot;&#10;        &quot;- Bars show current quantity; orange triangles mark each title's threshold.&lt;br&gt;&quot;&#10;        &quot;- Time series: blue line = quantity, orange dashed = threshold.&lt;br&gt;&quot;&#10;        &quot;- Event badges: blue=purchase, orange=low stock trigger, green=restock, red=out-of-stock.&quot;,&#10;        unsafe_allow_html=True,&#10;    )&#10;&#10;st.caption(&quot;Tip: Use the sidebar to step or run multiple steps, adjust thresholds, and reset the simulation. Colors and badges highlight threshold-driven behavior in real time.&quot;)&#10;" />
              <option name="updatedContent" value="import streamlit as st&#10;import io, csv, json&#10;import pandas as pd&#10;import altair as alt&#10;from datetime import datetime&#10;from owlready2 import destroy_entity&#10;from bookstore_mas.model import LibraryModel&#10;from bookstore_mas.ontology import onto, _first, reset_ontology, run_reasoner_safe, get_inventory_for_book&#10;&#10;# ----- Helpers -----&#10;&#10;def inventory_rows():&#10;    rows = []&#10;    for b in onto.Book.instances():&#10;        title = _first(b.hasTitle, b.name)&#10;        qty = int(_first(b.availableQuantity, 0) or 0)&#10;        thr = int(_first(b.restockThreshold, 0) or 0)&#10;        if qty &lt; thr:&#10;            state = &quot;Low&quot;&#10;        elif qty == thr:&#10;            state = &quot;At threshold&quot;&#10;        else:&#10;            state = &quot;OK&quot;&#10;        rows.append({&#10;            &quot;Title&quot;: title,&#10;            &quot;Author&quot;: _first(b.hasAuthor, &quot;&quot;),&#10;            &quot;Genre&quot;: _first(b.hasGenre, &quot;&quot;),&#10;            &quot;Qty&quot;: qty,&#10;            &quot;Threshold&quot;: thr,&#10;            &quot;State&quot;: state,&#10;            &quot;Price&quot;: float(_first(b.hasPrice, 0) or 0),&#10;        })&#10;    return rows&#10;&#10;&#10;def orders_rows():&#10;    rows = []&#10;    for o in onto.Order.instances():&#10;        rows.append({&#10;            &quot;Order ID&quot;: o.name,&#10;            &quot;Buyer&quot;: _first(_first(o.hasBuyer).hasName, _first(o.hasBuyer).name) if _first(o.hasBuyer) else &quot;&quot;,&#10;            &quot;Item&quot;: _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;,&#10;            &quot;Qty&quot;: int(_first(o.hasQuantity, 0) or 0),&#10;            &quot;Unit Price&quot;: float(_first(o.hasUnitPrice, 0) or 0),&#10;            &quot;Time&quot;: str(_first(o.orderTime, &quot;&quot;)),&#10;        })&#10;    return rows&#10;&#10;&#10;def low_stock_fallback(restock_default: int):&#10;    lows = []&#10;    for b in onto.Book.instances():&#10;        q = int(_first(b.availableQuantity, 0) or 0)&#10;        t = int(_first(b.restockThreshold, restock_default) or restock_default)&#10;        if q &lt; t:&#10;            lows.append(_first(b.hasTitle, b.name))&#10;    return lows&#10;&#10;&#10;def record_histories():&#10;    &quot;&quot;&quot;Record inventory quantities, thresholds, new purchases, and new UI events for the current step.&quot;&quot;&quot;&#10;    step = st.session_state.model.current_step&#10;    # Inventory history per book&#10;    for b in onto.Book.instances():&#10;        st.session_state.inv_history.append({&#10;            &quot;step&quot;: step,&#10;            &quot;Title&quot;: _first(b.hasTitle, b.name),&#10;            &quot;Qty&quot;: int(_first(b.availableQuantity, 0) or 0),&#10;            &quot;Threshold&quot;: int(_first(b.restockThreshold, st.session_state.restock_threshold) or st.session_state.restock_threshold),&#10;        })&#10;    # New orders detected in this step&#10;    current_ids = {o.name for o in onto.Order.instances()}&#10;    new_ids = current_ids - st.session_state.last_order_ids&#10;    if new_ids:&#10;        counts = {}&#10;        for oid in new_ids:&#10;            o = onto.search_one(iri=f&quot;*{oid}&quot;) or next((x for x in onto.Order.instances() if x.name == oid), None)&#10;            if not o:  # safety&#10;                continue&#10;            title = _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;&#10;            counts[title] = counts.get(title, 0) + int(_first(o.hasQuantity, 0) or 0)&#10;        for title, cnt in counts.items():&#10;            st.session_state.purchases_history.append({&#10;                &quot;step&quot;: step,&#10;                &quot;Title&quot;: title,&#10;                &quot;Count&quot;: cnt,&#10;            })&#10;    st.session_state.last_order_ids = current_ids&#10;    # Capture new UI events from the model&#10;    evts = st.session_state.model.ui_events&#10;    new_events = evts[st.session_state.events_seen:]&#10;    st.session_state.events_seen = len(evts)&#10;    if new_events:&#10;        st.session_state.event_feed.extend(new_events)&#10;&#10;&#10;def event_badge(evt_type: str) -&gt; str:&#10;    colors = {&#10;        &quot;purchase&quot;: &quot;#2563eb&quot;,        # blue&#10;        &quot;low_stock_trigger&quot;: &quot;#f59e0b&quot;, # amber&#10;        &quot;restock&quot;: &quot;#16a34a&quot;,         # green&#10;        &quot;out_of_stock&quot;: &quot;#dc2626&quot;,    # red&#10;    }&#10;    label = {&#10;        &quot;purchase&quot;: &quot;Purchase&quot;,&#10;        &quot;low_stock_trigger&quot;: &quot;Low stock&quot;,&#10;        &quot;restock&quot;: &quot;Restock&quot;,&#10;        &quot;out_of_stock&quot;: &quot;Out of stock&quot;,&#10;    }.get(evt_type, evt_type)&#10;    color = colors.get(evt_type, &quot;#6b7280&quot;)&#10;    return f'&lt;span style=&quot;background:{color};color:white;padding:2px 8px;border-radius:999px;font-size:12px;&quot;&gt;{label}&lt;/span&gt;'&#10;&#10;&#10;def render_event(evt: dict) -&gt; str:&#10;    t = evt.get(&quot;type&quot;)&#10;    step = evt.get(&quot;step&quot;)&#10;    badge = event_badge(t)&#10;    if t == &quot;purchase&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('customer')} bought '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' (qty {evt.get('qty_before')}→{evt.get('qty_after')}, thr {evt.get('threshold')})&quot;&#10;    if t == &quot;low_stock_trigger&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' fell below threshold (qty {evt.get('qty')}, thr {evt.get('threshold')}) — restock requested&quot;&#10;    if t == &quot;restock&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('employee')} restocked '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' (+{evt.get('added')}, {evt.get('qty_before')}→{evt.get('qty_after')})&quot;&#10;    if t == &quot;out_of_stock&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('customer')} tried to buy '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' but stock was {evt.get('qty')}&quot;&#10;    return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;&quot;&#10;&#10;&#10;def build_snapshot() -&gt; dict:&#10;    data = {&#10;        &quot;settings&quot;: {&#10;            &quot;restock_threshold&quot;: st.session_state.get(&quot;restock_threshold&quot;, 1),&#10;            &quot;restock_amount&quot;: st.session_state.get(&quot;restock_amount&quot;, 3),&#10;        },&#10;        &quot;books&quot;: [],&#10;        &quot;customers&quot;: [],&#10;        &quot;employees&quot;: [],&#10;        &quot;orders&quot;: [],&#10;    }&#10;    for b in onto.Book.instances():&#10;        data[&quot;books&quot;].append({&#10;            &quot;id&quot;: b.name,&#10;            &quot;title&quot;: _first(b.hasTitle, b.name),&#10;            &quot;author&quot;: _first(b.hasAuthor, &quot;&quot;),&#10;            &quot;genre&quot;: _first(b.hasGenre, &quot;&quot;),&#10;            &quot;price&quot;: float(_first(b.hasPrice, 0) or 0),&#10;            &quot;qty&quot;: int(_first(b.availableQuantity, 0) or 0),&#10;            &quot;threshold&quot;: int(_first(b.restockThreshold, 0) or 0),&#10;        })&#10;    for c in onto.Customer.instances():&#10;        data[&quot;customers&quot;].append({&quot;id&quot;: c.name, &quot;name&quot;: _first(c.hasName, c.name)})&#10;    for e in onto.Employee.instances():&#10;        data[&quot;employees&quot;].append({&quot;id&quot;: e.name, &quot;name&quot;: _first(e.hasName, e.name)})&#10;    for o in onto.Order.instances():&#10;        buyer = _first(o.hasBuyer)&#10;        item = _first(o.hasItem)&#10;        data[&quot;orders&quot;].append({&#10;            &quot;id&quot;: o.name,&#10;            &quot;buyer_id&quot;: buyer.name if buyer else None,&#10;            &quot;item_id&quot;: item.name if item else None,&#10;            &quot;qty&quot;: int(_first(o.hasQuantity, 0) or 0),&#10;            &quot;unit_price&quot;: float(_first(o.hasUnitPrice, 0) or 0),&#10;            &quot;time&quot;: str(_first(o.orderTime, &quot;&quot;)),&#10;        })&#10;    return data&#10;&#10;&#10;def load_snapshot(data: dict, replace: bool = True):&#10;    if replace:&#10;        # Clear all current instances&#10;        reset_ontology()&#10;    # Recreate books + inventory&#10;    existing_ids = set(x.name for x in onto.Book.instances())&#10;    id_map_books = {}&#10;    for rec in data.get(&quot;books&quot;, []):&#10;        bid = rec.get(&quot;id&quot;) or f&quot;book_{rec.get('title','book').lower().replace(' ','_')}&quot;&#10;        if bid in existing_ids:&#10;            # ensure uniqueness&#10;            base = bid&#10;            i = 1&#10;            while f&quot;{base}_{i}&quot; in existing_ids:&#10;                i += 1&#10;            bid = f&quot;{base}_{i}&quot;&#10;        b = onto.Book(bid)&#10;        b.hasTitle = rec.get(&quot;title&quot;) or bid&#10;        if rec.get(&quot;author&quot;): b.hasAuthor = rec[&quot;author&quot;]&#10;        if rec.get(&quot;genre&quot;): b.hasGenre = rec[&quot;genre&quot;]&#10;        b.hasPrice = float(rec.get(&quot;price&quot;, 0))&#10;        b.availableQuantity = int(rec.get(&quot;qty&quot;, 0))&#10;        b.restockThreshold = int(rec.get(&quot;threshold&quot;, 0))&#10;        inv = onto.Inventory(f&quot;inv_{bid}&quot;)&#10;        inv.tracksBook = b&#10;        inv.currentQuantity = int(rec.get(&quot;qty&quot;, 0))&#10;        existing_ids.add(bid)&#10;        id_map_books[rec.get(&quot;id&quot;, bid)] = b&#10;    # Recreate customers&#10;    existing_cids = set(x.name for x in onto.Customer.instances())&#10;    id_map_customers = {}&#10;    for rec in data.get(&quot;customers&quot;, []):&#10;        cid = rec.get(&quot;id&quot;) or f&quot;customer_{(rec.get('name') or 'c').lower().replace(' ','_')}&quot;&#10;        if cid in existing_cids:&#10;            base = cid; i=1&#10;            while f&quot;{base}_{i}&quot; in existing_cids:&#10;                i+=1&#10;            cid = f&quot;{base}_{i}&quot;&#10;        c = onto.Customer(cid)&#10;        if rec.get(&quot;name&quot;): c.hasName = rec[&quot;name&quot;]&#10;        existing_cids.add(cid)&#10;        id_map_customers[rec.get(&quot;id&quot;, cid)] = c&#10;    # Recreate employees&#10;    existing_eids = set(x.name for x in onto.Employee.instances())&#10;    id_map_employees = {}&#10;    for rec in data.get(&quot;employees&quot;, []):&#10;        eid = rec.get(&quot;id&quot;) or f&quot;employee_{(rec.get('name') or 'e').lower().replace(' ','_')}&quot;&#10;        if eid in existing_eids:&#10;            base=eid; i=1&#10;            while f&quot;{base}_{i}&quot; in existing_eids:&#10;                i+=1&#10;            eid = f&quot;{base}_{i}&quot;&#10;        e = onto.Employee(eid)&#10;        if rec.get(&quot;name&quot;): e.hasName = rec[&quot;name&quot;]&#10;        existing_eids.add(eid)&#10;        id_map_employees[rec.get(&quot;id&quot;, eid)] = e&#10;    # Recreate orders and purchases relation&#10;    for rec in data.get(&quot;orders&quot;, []):&#10;        oid = rec.get(&quot;id&quot;) or f&quot;order_{len(onto.Order.instances())+1}&quot;&#10;        # ensure uniqueness&#10;        exists = {x.name for x in onto.Order.instances()}&#10;        if oid in exists:&#10;            base=oid; i=1&#10;            while f&quot;{base}_{i}&quot; in exists:&#10;                i+=1&#10;            oid = f&quot;{base}_{i}&quot;&#10;        o = onto.Order(oid)&#10;        # Link buyer &amp; item&#10;        buyer = id_map_customers.get(rec.get(&quot;buyer_id&quot;))&#10;        item = id_map_books.get(rec.get(&quot;item_id&quot;))&#10;        if buyer: o.hasBuyer = buyer&#10;        if item: o.hasItem = item&#10;        if buyer and item:&#10;            # maintain purchases relation for convenience&#10;            if item not in (buyer.purchases or []):&#10;                buyer.purchases.append(item)&#10;        o.hasQuantity = int(rec.get(&quot;qty&quot;, 1) or 1)&#10;        o.hasUnitPrice = float(rec.get(&quot;unit_price&quot;, 0) or 0)&#10;        t = rec.get(&quot;time&quot;)&#10;        if t:&#10;            try:&#10;                # allow plain str storage; keep as string if not parseable&#10;                o.orderTime = t&#10;            except Exception:&#10;                o.orderTime = str(t)&#10;    # Update settings / model&#10;    settings = data.get(&quot;settings&quot;, {})&#10;    st.session_state.restock_threshold = int(settings.get(&quot;restock_threshold&quot;, st.session_state.get(&quot;restock_threshold&quot;, 1)))&#10;    st.session_state.restock_amount = int(settings.get(&quot;restock_amount&quot;, st.session_state.get(&quot;restock_amount&quot;, 3)))&#10;    # Rebuild model to reflect new ontology&#10;    st.session_state.model = LibraryModel(&#10;        restock_threshold=st.session_state.restock_threshold,&#10;        restock_amount=st.session_state.restock_amount,&#10;    )&#10;    st.session_state.steps = 0&#10;    st.session_state.inv_history = []&#10;    st.session_state.purchases_history = []&#10;    st.session_state.last_order_ids = set()&#10;    st.session_state.event_feed = []&#10;    st.session_state.events_seen = 0&#10;&#10;# ----- App state -----&#10;&#10;if &quot;restock_threshold&quot; not in st.session_state:&#10;    st.session_state.restock_threshold = 1&#10;if &quot;restock_amount&quot; not in st.session_state:&#10;    st.session_state.restock_amount = 3&#10;if &quot;model&quot; not in st.session_state:&#10;    reset_ontology()&#10;    st.session_state.model = LibraryModel(&#10;        restock_threshold=st.session_state.restock_threshold,&#10;        restock_amount=st.session_state.restock_amount,&#10;    )&#10;    st.session_state.steps = 0&#10;    st.session_state.inv_history = []&#10;    st.session_state.purchases_history = []&#10;    st.session_state.last_order_ids = set()&#10;    st.session_state.event_feed = []&#10;    st.session_state.events_seen = 0&#10;&#10;# ----- UI -----&#10;&#10;st.set_page_config(page_title=&quot;Bookstore MAS&quot;, layout=&quot;wide&quot;)&#10;st.title(&quot;Bookstore Management System - MAS + Ontology&quot;)&#10;&#10;with st.expander(&quot;Setup: define inventory and participants&quot;, expanded=False):&#10;    # Add book form&#10;    st.subheader(&quot;Books&quot;)&#10;    with st.form(&quot;add_book_form&quot;, clear_on_submit=True):&#10;        colA, colB, colC = st.columns([2,2,1])&#10;        with colA:&#10;            in_title = st.text_input(&quot;Title&quot;, placeholder=&quot;e.g., Python Basics&quot;)&#10;            in_author = st.text_input(&quot;Author&quot;, placeholder=&quot;e.g., Jane Smith&quot;)&#10;            in_genre = st.text_input(&quot;Genre&quot;, placeholder=&quot;e.g., Programming&quot;)&#10;        with colB:&#10;            in_price = st.number_input(&quot;Price&quot;, min_value=0.0, step=0.5, value=10.0)&#10;            in_qty = st.number_input(&quot;Quantity&quot;, min_value=0, step=1, value=1)&#10;            in_thr = st.number_input(&quot;Restock threshold&quot;, min_value=0, step=1, value=1)&#10;        submitted = st.form_submit_button(&quot;Add book&quot;)&#10;        if submitted:&#10;            title = in_title.strip()&#10;            if not title:&#10;                st.warning(&quot;Please enter a title&quot;)&#10;            else:&#10;                # Build a safe unique ID&#10;                base = ''.join(ch.lower() if ch.isalnum() else '_' for ch in title).strip('_')&#10;                if not base:&#10;                    base = 'book'&#10;                bid = f&quot;book_{base}&quot;&#10;                # ensure uniqueness&#10;                existing = {b.name for b in onto.Book.instances()}&#10;                suffix = 1&#10;                new_id = bid&#10;                while new_id in existing:&#10;                    suffix += 1&#10;                    new_id = f&quot;{bid}_{suffix}&quot;&#10;                b = onto.Book(new_id)&#10;                b.hasTitle = title&#10;                if in_author:&#10;                    b.hasAuthor = in_author&#10;                if in_genre:&#10;                    b.hasGenre = in_genre&#10;                b.hasPrice = float(in_price)&#10;                b.availableQuantity = int(in_qty)&#10;                b.restockThreshold = int(in_thr)&#10;                inv = onto.Inventory(f&quot;inv_{new_id}&quot;)&#10;                inv.tracksBook = b&#10;                inv.currentQuantity = int(in_qty)&#10;                st.success(f&quot;Added book '{title}' (qty {int(in_qty)}, thr {int(in_thr)})&quot;)&#10;    # Existing books &amp; delete&#10;    books_df = pd.DataFrame([{ 'ID': b.name, 'Title': _first(b.hasTitle,b.name)} for b in onto.Book.instances()])&#10;    if not books_df.empty:&#10;        sel = st.multiselect(&quot;Select books to delete&quot;, options=books_df['Title'].tolist())&#10;        if st.button(&quot;Delete selected books&quot;):&#10;            del_count = 0&#10;            for b in list(onto.Book.instances()):&#10;                if _first(b.hasTitle, b.name) in sel:&#10;                    # delete inventory first, then book&#10;                    inv = get_inventory_for_book(b)&#10;                    if inv is not None:&#10;                        destroy_entity(inv)&#10;                    destroy_entity(b)&#10;                    del_count += 1&#10;            st.success(f&quot;Deleted {del_count} book(s)&quot;)&#10;    else:&#10;        st.info(&quot;No books yet.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    # Customers&#10;    st.subheader(&quot;Customers&quot;)&#10;    col1, col2 = st.columns([2,1])&#10;    with col1:&#10;        cust_name = st.text_input(&quot;New customer name&quot;, key=&quot;cust_name&quot;)&#10;    with col2:&#10;        if st.button(&quot;Add customer&quot;):&#10;            if not cust_name.strip():&#10;                st.warning(&quot;Enter a name&quot;)&#10;            else:&#10;                cname = cust_name.strip()&#10;                cid = f&quot;customer_{''.join(ch.lower() if ch.isalnum() else '_' for ch in cname).strip('_') or 'c'}&quot;&#10;                # ensure uniqueness&#10;                exists = {c.name for c in onto.Customer.instances()}&#10;                i=1; nid=cid&#10;                while nid in exists:&#10;                    i+=1; nid=f&quot;{cid}_{i}&quot;&#10;                c = onto.Customer(nid)&#10;                c.hasName = cname&#10;                st.success(f&quot;Added customer '{cname}'&quot;)&#10;    custs = [ _first(c.hasName, c.name) for c in onto.Customer.instances() ]&#10;    if custs:&#10;        del_custs = st.multiselect(&quot;Delete customers&quot;, options=custs, key=&quot;del_custs&quot;)&#10;        if st.button(&quot;Delete selected customers&quot;):&#10;            d=0&#10;            for c in list(onto.Customer.instances()):&#10;                if _first(c.hasName, c.name) in del_custs:&#10;                    destroy_entity(c); d+=1&#10;            st.success(f&quot;Deleted {d} customer(s)&quot;)&#10;    else:&#10;        st.caption(&quot;No customers yet.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    # Employees&#10;    st.subheader(&quot;Employees&quot;)&#10;    col3, col4 = st.columns([2,1])&#10;    with col3:&#10;        emp_name = st.text_input(&quot;New employee name&quot;, key=&quot;emp_name&quot;)&#10;    with col4:&#10;        if st.button(&quot;Add employee&quot;):&#10;            if not emp_name.strip():&#10;                st.warning(&quot;Enter a name&quot;)&#10;            else:&#10;                ename = emp_name.strip()&#10;                eid = f&quot;employee_{''.join(ch.lower() if ch.isalnum() else '_' for ch in ename).strip('_') or 'e'}&quot;&#10;                exists = {e.name for e in onto.Employee.instances()}&#10;                i=1; nid=eid&#10;                while nid in exists:&#10;                    i+=1; nid=f&quot;{eid}_{i}&quot;&#10;                e = onto.Employee(nid)&#10;                e.hasName = ename&#10;                st.success(f&quot;Added employee '{ename}'&quot;)&#10;    emps = [ _first(e.hasName, e.name) for e in onto.Employee.instances() ]&#10;    if emps:&#10;        del_emps = st.multiselect(&quot;Delete employees&quot;, options=emps, key=&quot;del_emps&quot;)&#10;        if st.button(&quot;Delete selected employees&quot;):&#10;            d=0&#10;            for e in list(onto.Employee.instances()):&#10;                if _first(e.hasName, e.name) in del_emps:&#10;                    destroy_entity(e); d+=1&#10;            st.success(f&quot;Deleted {d} employee(s)&quot;)&#10;    else:&#10;        st.caption(&quot;No employees yet.&quot;)&#10;&#10;with st.sidebar:&#10;    st.header(&quot;Controls&quot;)&#10;    rt = st.number_input(&quot;Restock threshold&quot;, min_value=0, max_value=100, value=st.session_state.restock_threshold, step=1)&#10;    ra = st.number_input(&quot;Restock amount&quot;, min_value=0, max_value=100, value=st.session_state.restock_amount, step=1)&#10;    colA, colB = st.columns(2)&#10;    with colA:&#10;        reset_keep = st.button(&quot;Reset simulation\n(keep data)&quot;)&#10;    with colB:&#10;        reset_sample = st.button(&quot;Load sample\n(reset all)&quot;)&#10;&#10;    if reset_keep:&#10;        st.session_state.restock_threshold = int(rt)&#10;        st.session_state.restock_amount = int(ra)&#10;        st.session_state.model = LibraryModel(&#10;            restock_threshold=st.session_state.restock_threshold,&#10;            restock_amount=st.session_state.restock_amount,&#10;        )&#10;        st.session_state.steps = 0&#10;        st.session_state.inv_history = []&#10;        st.session_state.purchases_history = []&#10;        st.session_state.last_order_ids = set()&#10;        st.session_state.event_feed = []&#10;        st.session_state.events_seen = 0&#10;        st.success(&quot;Simulation reset (kept current data).&quot;)&#10;&#10;    if reset_sample:&#10;        st.session_state.restock_threshold = int(rt)&#10;        st.session_state.restock_amount = int(ra)&#10;        reset_ontology()&#10;        st.session_state.model = LibraryModel(&#10;            restock_threshold=st.session_state.restock_threshold,&#10;            restock_amount=st.session_state.restock_amount,&#10;        )&#10;        st.session_state.steps = 0&#10;        st.session_state.inv_history = []&#10;        st.session_state.purchases_history = []&#10;        st.session_state.last_order_ids = set()&#10;        st.session_state.event_feed = []&#10;        st.session_state.events_seen = 0&#10;        st.success(&quot;Loaded sample data and reset simulation.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    step_once = st.button(&quot;Step once&quot;)&#10;    step_n = st.number_input(&quot;Run N steps&quot;, min_value=1, max_value=1000, value=10, step=1)&#10;    run_n = st.button(&quot;Run N steps ▶&quot;)&#10;    st.markdown(&quot;---&quot;)&#10;    if st.button(&quot;Run reasoner (SWRL)&quot;):&#10;        run_reasoner_safe()&#10;        st.toast(&quot;Reasoner executed (see terminal logs for details)&quot;)&#10;&#10;# Step controls&#10;if step_once:&#10;    st.session_state.model.step()&#10;    st.session_state.steps += 1&#10;    record_histories()&#10;if run_n:&#10;    for _ in range(int(step_n)):&#10;        st.session_state.model.step()&#10;        st.session_state.steps += 1&#10;        record_histories()&#10;&#10;# Summary metrics&#10;col1, col2, col3 = st.columns(3)&#10;col1.metric(&quot;Steps&quot;, st.session_state.steps)&#10;col2.metric(&quot;Current step (model)&quot;, st.session_state.model.current_step)&#10;col3.metric(&quot;Restock threshold&quot;, st.session_state.restock_threshold)&#10;&#10;# Data + Exports&#10;left, right = st.columns(2)&#10;with left:&#10;    st.subheader(&quot;Inventory&quot;)&#10;    inv_df = pd.DataFrame(inventory_rows())&#10;    st.dataframe(inv_df, use_container_width=True)&#10;    # Export inventory CSV&#10;    inv_buf = io.StringIO()&#10;    writer = csv.DictWriter(inv_buf, fieldnames=list(inv_df.columns))&#10;    writer.writeheader()&#10;    for row in inv_df.to_dict(orient=&quot;records&quot;):&#10;        writer.writerow(row)&#10;    st.download_button(&#10;        label=&quot;Download Inventory CSV&quot;,&#10;        data=inv_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;inventory.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;    lows = low_stock_fallback(st.session_state.restock_threshold)&#10;    st.caption(f&quot;Low-stock (fallback): {lows if lows else 'None'}&quot;)&#10;&#10;with right:&#10;    st.subheader(&quot;Orders&quot;)&#10;    orders_df = pd.DataFrame(orders_rows())&#10;    st.dataframe(orders_df, use_container_width=True)&#10;    # Export orders CSV&#10;    ord_buf = io.StringIO()&#10;    if not orders_df.empty:&#10;        writer = csv.DictWriter(ord_buf, fieldnames=list(orders_df.columns))&#10;        writer.writeheader()&#10;        for row in orders_df.to_dict(orient=&quot;records&quot;):&#10;            writer.writerow(row)&#10;    else:&#10;        ord_buf.write(&quot;Order ID,Buyer,Item,Qty,Unit Price,Time\n&quot;)&#10;    st.download_button(&#10;        label=&quot;Download Orders CSV&quot;,&#10;        data=ord_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;orders.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;&#10;# Charts&#10;st.subheader(&quot;Charts&quot;)&#10;chart_left, chart_right = st.columns(2)&#10;with chart_left:&#10;    st.caption(&quot;Current stock vs threshold&quot;)&#10;    if not inv_df.empty:&#10;        inv_df_chart = inv_df.copy()&#10;        def state_color(state: str) -&gt; str:&#10;            return {&quot;Low&quot;: &quot;#dc2626&quot;, &quot;At threshold&quot;: &quot;#f59e0b&quot;, &quot;OK&quot;: &quot;#16a34a&quot;}.get(state, &quot;#6b7280&quot;)&#10;        inv_df_chart[&quot;Color&quot;] = inv_df_chart[&quot;State&quot;].map(state_color)&#10;        bar = alt.Chart(inv_df_chart).mark_bar().encode(&#10;            x=alt.X(&quot;Title:N&quot;, sort=None),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;State:N&quot;, scale=alt.Scale(domain=[&quot;Low&quot;,&quot;At threshold&quot;,&quot;OK&quot;], range=[&quot;#dc2626&quot;,&quot;#f59e0b&quot;,&quot;#16a34a&quot;])),&#10;            tooltip=[&quot;Title&quot;,&quot;Qty&quot;,&quot;Threshold&quot;,&quot;State&quot;,&quot;Price&quot;],&#10;        )&#10;        # Threshold rule per bar is not trivial; show as points overlayed for clarity&#10;        thr_points = alt.Chart(inv_df_chart).mark_point(shape=&quot;triangle-down&quot;, size=120, color=&quot;#f59e0b&quot;).encode(&#10;            x=alt.X(&quot;Title:N&quot;), y=alt.Y(&quot;Threshold:Q&quot;), tooltip=[&quot;Title&quot;,&quot;Threshold&quot;],&#10;        )&#10;        st.altair_chart((bar + thr_points), use_container_width=True)&#10;    else:&#10;        st.info(&quot;No inventory to chart.&quot;)&#10;&#10;with chart_right:&#10;    st.caption(&quot;Inventory over steps vs threshold&quot;)&#10;    inv_hist_df = pd.DataFrame(st.session_state.get(&quot;inv_history&quot;, []))&#10;    if not inv_hist_df.empty:&#10;        qty_line = alt.Chart(inv_hist_df).mark_line(point=True, color=&quot;#2563eb&quot;).encode(&#10;            x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;Title:N&quot;, legend=alt.Legend(title=&quot;Book&quot;)),&#10;            tooltip=[&quot;step:Q&quot;,&quot;Title:N&quot;,&quot;Qty:Q&quot;,&quot;Threshold:Q&quot;],&#10;        )&#10;        thr_line = alt.Chart(inv_hist_df).mark_line(strokeDash=[6,4], color=&quot;#f59e0b&quot;).encode(&#10;            x=alt.X(&quot;step:Q&quot;), y=alt.Y(&quot;Threshold:Q&quot;), color=alt.Color(&quot;Title:N&quot;, legend=None),&#10;        )&#10;        st.altair_chart(qty_line + thr_line, use_container_width=True)&#10;    else:&#10;        st.info(&quot;Step the simulation to build the time series.&quot;)&#10;&#10;st.subheader(&quot;Purchases over time&quot;)&#10;p_hist_df = pd.DataFrame(st.session_state.get(&quot;purchases_history&quot;, []))&#10;if not p_hist_df.empty:&#10;    bars = alt.Chart(p_hist_df).mark_bar().encode(&#10;        x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;        y=alt.Y(&quot;Count:Q&quot;, title=&quot;Purchases&quot;),&#10;        color=alt.Color(&quot;Title:N&quot;, title=&quot;Book&quot;),&#10;        tooltip=[&quot;step:Q&quot;, &quot;Title:N&quot;, &quot;Count:Q&quot;],&#10;    )&#10;    st.altair_chart(bars, use_container_width=True)&#10;else:&#10;    st.info(&quot;No purchases recorded yet. Step the simulation to generate data.&quot;)&#10;&#10;# Purchases summary&#10;st.subheader(&quot;Purchases by customer&quot;)&#10;rows = []&#10;for c in onto.Customer.instances():&#10;    rows.append({&#10;        &quot;Customer&quot;: _first(c.hasName, c.name),&#10;        &quot;Purchases&quot;: &quot;, &quot;.join(_first(b.hasTitle, b.name) for b in (c.purchases or [])),&#10;    })&#10;st.table(rows)&#10;&#10;# Event timeline&#10;st.subheader(&quot;Event timeline&quot;)&#10;with st.container(border=True):&#10;    if st.session_state.event_feed:&#10;        for evt in reversed(st.session_state.event_feed[-30:]):  # show last 30 events&#10;            st.markdown(render_event(evt), unsafe_allow_html=True)&#10;    else:&#10;        st.info(&quot;No events yet. Step the simulation to see purchases, low-stock triggers, and restocks.&quot;)&#10;&#10;# Legend&#10;with st.expander(&quot;Legend: colors and thresholds&quot;):&#10;    st.markdown(&#10;        &quot;- State colors: &lt;span style='color:#16a34a;'&gt;OK&lt;/span&gt;, &lt;span style='color:#f59e0b;'&gt;At threshold&lt;/span&gt;, &lt;span style='color:#dc2626;'&gt;Low&lt;/span&gt;&lt;br&gt;&quot;&#10;        &quot;- Bars show current quantity; orange triangles mark each title's threshold.&lt;br&gt;&quot;&#10;        &quot;- Time series: blue line = quantity, orange dashed = threshold.&lt;br&gt;&quot;&#10;        &quot;- Event badges: blue=purchase, orange=low stock trigger, green=restock, red=out-of-stock.&quot;,&#10;        unsafe_allow_html=True,&#10;    )&#10;&#10;st.caption(&quot;Tip: Use the sidebar to step or run multiple steps, adjust thresholds, and reset the simulation. Colors and badges highlight threshold-driven behavior in real time.&quot;)&#10;&#10;with st.expander(&quot;Save / Load&quot;, expanded=False):&#10;    st.subheader(&quot;Save current data&quot;)&#10;    snap = build_snapshot()&#10;    json_bytes = json.dumps(snap, indent=2).encode(&quot;utf-8&quot;)&#10;    st.download_button(&quot;Download JSON snapshot&quot;, data=json_bytes, file_name=&quot;bookstore_snapshot.json&quot;, mime=&quot;application/json&quot;)&#10;    st.caption(&quot;Includes settings, books + inventory, customers, employees, and orders.&quot;)&#10;&#10;    st.subheader(&quot;Load data from JSON&quot;)&#10;    up = st.file_uploader(&quot;Choose a snapshot JSON file&quot;, type=[&quot;json&quot;]) &#10;    if up is not None:&#10;        try:&#10;            incoming = json.loads(up.read().decode(&quot;utf-8&quot;))&#10;            st.success(&quot;File parsed. Choose a load option below.&quot;)&#10;            c1, c2 = st.columns(2)&#10;            with c1:&#10;                if st.button(&quot;Load (replace all)&quot;):&#10;                    load_snapshot(incoming, replace=True)&#10;                    st.success(&quot;Loaded snapshot and reset simulation.&quot;)&#10;            with c2:&#10;                if st.button(&quot;Load (append)&quot;):&#10;                    load_snapshot(incoming, replace=False)&#10;                    st.success(&quot;Appended snapshot and reset simulation.&quot;)&#10;        except Exception as e:&#10;            st.error(f&quot;Failed to parse JSON: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>