<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/bookstore_mas/agents.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bookstore_mas/agents.py" />
              <option name="originalContent" value="# Minimal local Agent base to avoid dependency on mesa.Agent init quirks&#10;class Agent:&#10;    def __init__(self, unique_id, model):&#10;        self.unique_id = unique_id&#10;        self.model = model&#10;&#10;    def step(self):&#10;        pass&#10;&#10;import random&#10;from .ontology import _first, get_inventory_for_book, create_order&#10;&#10;class BookAgent(Agent):&#10;    def __init__(self, unique_id, model, book_onto):&#10;        super().__init__(unique_id, model)&#10;        self.book = book_onto&#10;&#10;    def step(self):&#10;        return&#10;&#10;&#10;class CustomerAgent(Agent):&#10;    def __init__(self, unique_id, model, customer_onto):&#10;        super().__init__(unique_id, model)&#10;        self.customer = customer_onto&#10;&#10;    def _iter_schedule_agents(self):&#10;        src = getattr(self.model.schedule, &quot;agents&quot;, [])&#10;        if isinstance(src, dict):&#10;            return list(src.values())&#10;        try:&#10;            # If it's a set or other iterable&#10;            return list(src)&#10;        except Exception:&#10;            return []&#10;&#10;    def step(self):&#10;        all_agents = self._iter_schedule_agents()&#10;        book_agents = [a for a in all_agents if isinstance(a, BookAgent)]&#10;        if not book_agents:&#10;            return&#10;&#10;        book_agent = random.choice(book_agents)&#10;        book = book_agent.book&#10;        qty = int(_first(book.availableQuantity, 0) or 0)&#10;&#10;        if qty &gt; 0:&#10;            # Decrement book stock&#10;            book.availableQuantity = qty - 1&#10;            # Decrement inventory stock if present&#10;            inv = get_inventory_for_book(book)&#10;            if inv is not None:&#10;                inv_qty = int(_first(inv.currentQuantity, 0) or 0)&#10;                inv.currentQuantity = max(inv_qty - 1, 0)&#10;&#10;            # Create an order linking customer and book&#10;            create_order(self.customer, book, 1)&#10;&#10;            print(&#10;                f&quot;[Step {self.model.current_step}] {_first(self.customer.hasName, '?')} &quot;&#10;                f&quot;purchased '{_first(book.hasTitle, book.name)}' -&gt; qty {qty-1}&quot;&#10;            )&#10;&#10;            # Determine threshold from book or model&#10;            thresh = int(_first(book.restockThreshold, self.model.restock_threshold) or self.model.restock_threshold)&#10;            if qty - 1 &lt; thresh:&#10;                self.model.message_bus.publish({&#10;                    &quot;type&quot;: &quot;restock_request&quot;,&#10;                    &quot;book&quot;: book&#10;                })&#10;        else:&#10;            print(&#10;                f&quot;[Step {self.model.current_step}] {_first(self.customer.hasName, '?')} tried to purchase &quot;&#10;                f&quot;'{_first(book.hasTitle, book.name)}' but it's out of stock&quot;&#10;            )&#10;&#10;&#10;class EmployeeAgent(Agent):&#10;    def __init__(self, unique_id, model, employee_onto, restock_amount=3):&#10;        super().__init__(unique_id, model)&#10;        self.employee = employee_onto&#10;        self.restock_amount = restock_amount&#10;&#10;    def step(self):&#10;        msgs = self.model.message_bus.get_messages(&quot;restock_request&quot;)&#10;        for msg in msgs:&#10;            book = msg[&quot;book&quot;]&#10;            qty = int(_first(book.availableQuantity, 0) or 0)&#10;            new_qty = qty + self.restock_amount&#10;            # Update book stock&#10;            book.availableQuantity = new_qty&#10;&#10;            # Update inventory stock if present&#10;            inv = get_inventory_for_book(book)&#10;            if inv is not None:&#10;                inv_qty = int(_first(inv.currentQuantity, 0) or 0)&#10;                inv.currentQuantity = inv_qty + self.restock_amount&#10;&#10;            print(&#10;                f&quot;[Step {self.model.current_step}] {_first(self.employee.hasName, '?')} restocked &quot;&#10;                f&quot;'{_first(book.hasTitle, book.name)}' -&gt; qty {new_qty}&quot;&#10;            )&#10;" />
              <option name="updatedContent" value="# Minimal local Agent base to avoid dependency on mesa.Agent init quirks&#10;class Agent:&#10;    def __init__(self, unique_id, model):&#10;        self.unique_id = unique_id&#10;        self.model = model&#10;&#10;    def step(self):&#10;        pass&#10;&#10;import random&#10;from .ontology import _first, get_inventory_for_book, create_order&#10;&#10;class BookAgent(Agent):&#10;    def __init__(self, unique_id, model, book_onto):&#10;        super().__init__(unique_id, model)&#10;        self.book = book_onto&#10;&#10;    def step(self):&#10;        return&#10;&#10;&#10;class CustomerAgent(Agent):&#10;    def __init__(self, unique_id, model, customer_onto):&#10;        super().__init__(unique_id, model)&#10;        self.customer = customer_onto&#10;&#10;    def _iter_schedule_agents(self):&#10;        src = getattr(self.model.schedule, &quot;agents&quot;, [])&#10;        if isinstance(src, dict):&#10;            return list(src.values())&#10;        try:&#10;            # If it's a set or other iterable&#10;            return list(src)&#10;        except Exception:&#10;            return []&#10;&#10;    def step(self):&#10;        all_agents = self._iter_schedule_agents()&#10;        book_agents = [a for a in all_agents if isinstance(a, BookAgent)]&#10;        if not book_agents:&#10;            return&#10;&#10;        book_agent = random.choice(book_agents)&#10;        book = book_agent.book&#10;        qty = int(_first(book.availableQuantity, 0) or 0)&#10;        cust_name = _first(self.customer.hasName, &quot;?&quot;)&#10;        title = _first(book.hasTitle, book.name)&#10;&#10;        if qty &gt; 0:&#10;            # Decrement book stock&#10;            book.availableQuantity = qty - 1&#10;            # Decrement inventory stock if present&#10;            inv = get_inventory_for_book(book)&#10;            if inv is not None:&#10;                inv_qty = int(_first(inv.currentQuantity, 0) or 0)&#10;                inv.currentQuantity = max(inv_qty - 1, 0)&#10;&#10;            # Create an order linking customer and book&#10;            create_order(self.customer, book, 1)&#10;&#10;            # Determine threshold from book or model&#10;            thresh = int(_first(book.restockThreshold, self.model.restock_threshold) or self.model.restock_threshold)&#10;&#10;            # UI event: purchase&#10;            self.model.ui_events.append({&#10;                &quot;step&quot;: self.model.current_step,&#10;                &quot;type&quot;: &quot;purchase&quot;,&#10;                &quot;customer&quot;: cust_name,&#10;                &quot;book&quot;: title,&#10;                &quot;qty_before&quot;: qty,&#10;                &quot;qty_after&quot;: qty - 1,&#10;                &quot;threshold&quot;: thresh,&#10;                &quot;below_threshold&quot;: (qty - 1) &lt; thresh,&#10;            })&#10;&#10;            # Publish restock request if below threshold&#10;            if qty - 1 &lt; thresh:&#10;                self.model.message_bus.publish({&#10;                    &quot;type&quot;: &quot;restock_request&quot;,&#10;                    &quot;book&quot;: book&#10;                })&#10;                # UI event: low-stock trigger&#10;                self.model.ui_events.append({&#10;                    &quot;step&quot;: self.model.current_step,&#10;                    &quot;type&quot;: &quot;low_stock_trigger&quot;,&#10;                    &quot;book&quot;: title,&#10;                    &quot;qty&quot;: qty - 1,&#10;                    &quot;threshold&quot;: thresh,&#10;                })&#10;        else:&#10;            # UI event: out-of-stock attempt&#10;            self.model.ui_events.append({&#10;                &quot;step&quot;: self.model.current_step,&#10;                &quot;type&quot;: &quot;out_of_stock&quot;,&#10;                &quot;customer&quot;: cust_name,&#10;                &quot;book&quot;: title,&#10;                &quot;qty&quot;: qty,&#10;            })&#10;&#10;&#10;class EmployeeAgent(Agent):&#10;    def __init__(self, unique_id, model, employee_onto, restock_amount=3):&#10;        super().__init__(unique_id, model)&#10;        self.employee = employee_onto&#10;        self.restock_amount = restock_amount&#10;&#10;    def step(self):&#10;        msgs = self.model.message_bus.get_messages(&quot;restock_request&quot;)&#10;        for msg in msgs:&#10;            book = msg[&quot;book&quot;]&#10;            qty = int(_first(book.availableQuantity, 0) or 0)&#10;            new_qty = qty + self.restock_amount&#10;            # Update book stock&#10;            book.availableQuantity = new_qty&#10;&#10;            # Update inventory stock if present&#10;            inv = get_inventory_for_book(book)&#10;            if inv is not None:&#10;                inv_qty = int(_first(inv.currentQuantity, 0) or 0)&#10;                inv.currentQuantity = inv_qty + self.restock_amount&#10;&#10;            emp_name = _first(self.employee.hasName, &quot;?&quot;)&#10;            title = _first(book.hasTitle, book.name)&#10;&#10;            # UI event: restock&#10;            self.model.ui_events.append({&#10;                &quot;step&quot;: self.model.current_step,&#10;                &quot;type&quot;: &quot;restock&quot;,&#10;                &quot;employee&quot;: emp_name,&#10;                &quot;book&quot;: title,&#10;                &quot;added&quot;: self.restock_amount,&#10;                &quot;qty_before&quot;: qty,&#10;                &quot;qty_after&quot;: new_qty,&#10;            })&#10;&#10;            print(&#10;                f&quot;[Step {self.model.current_step}] {emp_name} restocked &quot;&#10;                f&quot;'{title}' -&gt; qty {new_qty}&quot;&#10;            )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bookstore_mas/model.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bookstore_mas/model.py" />
              <option name="originalContent" value="from mesa import Model&#10;from importlib import import_module&#10;&#10;# Resolve RandomActivation across Mesa versions with a minimal fallback&#10;&#10;def _resolve_random_activation():&#10;    candidates = [&#10;        (&quot;mesa.time&quot;, &quot;RandomActivation&quot;),      # Mesa &lt;= 2.x&#10;        (&quot;mesa.scheduler&quot;, &quot;RandomActivation&quot;), # Mesa 3.x&#10;        (&quot;mesa.timekeeping&quot;, &quot;RandomActivation&quot;),&#10;    ]&#10;    for mod_name, attr in candidates:&#10;        try:&#10;            mod = import_module(mod_name)&#10;            ra = getattr(mod, attr)&#10;            return ra&#10;        except Exception:&#10;            continue&#10;&#10;    # Fallback scheduler&#10;    import random as _random&#10;&#10;    class _RandomActivationFallback:  # type: ignore&#10;        def __init__(self, model):&#10;            self.model = model&#10;            self._agents = []&#10;&#10;        @property&#10;        def agents(self):&#10;            return list(self._agents)&#10;&#10;        def add(self, agent):&#10;            self._agents.append(agent)&#10;&#10;        def step(self):&#10;            _random.shuffle(self._agents)&#10;            for a in list(self._agents):&#10;                a.step()&#10;&#10;    return _RandomActivationFallback&#10;&#10;_RandomActivation = _resolve_random_activation()&#10;&#10;from .ontology import onto, create_sample_data, list_inventory, _first, run_reasoner_safe, list_purchases, LOW_STOCK_RULE_ENABLED&#10;from .agents import BookAgent, CustomerAgent, EmployeeAgent&#10;from .message_bus import MessageBus&#10;&#10;&#10;class LibraryModel(Model):&#10;    def __init__(self, restock_threshold=1, restock_amount=3):&#10;        super().__init__()&#10;        self.schedule = _RandomActivation(self)&#10;        self.current_step = 0&#10;        self.restock_threshold = restock_threshold&#10;        self.restock_amount = restock_amount&#10;        self.message_bus = MessageBus()&#10;&#10;        create_sample_data()&#10;&#10;        # Ensure each book has a restock threshold set (use model default if missing)&#10;        for b in onto.Book.instances():&#10;            if _first(b.restockThreshold, None) is None:&#10;                b.restockThreshold = self.restock_threshold&#10;&#10;        uid = 0&#10;        for b in onto.Book.instances():&#10;            self.schedule.add(BookAgent(uid, self, b)); uid += 1&#10;        for c in onto.Customer.instances():&#10;            self.schedule.add(CustomerAgent(uid, self, c)); uid += 1&#10;        for e in onto.Employee.instances():&#10;            # Pass configured restock amount&#10;            self.schedule.add(EmployeeAgent(uid, self, e, restock_amount=self.restock_amount)); uid += 1&#10;&#10;    def step(self):&#10;        self.schedule.step()&#10;        self.current_step += 1&#10;&#10;    def run(self, steps=5):&#10;        print(&quot;Initial inventory:&quot;)&#10;        list_inventory()&#10;&#10;        for i in range(steps):&#10;            print(f&quot;\n--- Simulation step {i+1} ---&quot;)&#10;            self.step()&#10;&#10;        print(&quot;\nFinal inventory:&quot;)&#10;        list_inventory()&#10;&#10;        # Optional: run reasoner to apply SWRL rules&#10;        run_reasoner_safe()&#10;&#10;        # Summary of purchases (explicit + inferred)&#10;        print(&quot;\nPurchase summary:&quot;)&#10;        list_purchases()&#10;&#10;        # SWRL low-stock classification (if reasoner available) with Python fallback&#10;        titles_swrl = []&#10;        try:&#10;            titles_swrl = [ _first(b.hasTitle, b.name) for b in onto.LowStockBook.instances() ]&#10;        except Exception:&#10;            titles_swrl = []&#10;&#10;        if titles_swrl:&#10;            print(f&quot;Low-stock classification (SWRL): {titles_swrl}&quot;)&#10;        else:&#10;            # Fallback classification based on numeric comparison&#10;            fallback = []&#10;            for b in onto.Book.instances():&#10;                q = int(_first(b.availableQuantity, 0) or 0)&#10;                t = int(_first(b.restockThreshold, self.restock_threshold) or self.restock_threshold)&#10;                if q &lt; t:&#10;                    fallback.append(_first(b.hasTitle, b.name))&#10;            print(f&quot;Low-stock classification (fallback): {fallback}&quot;)&#10;" />
              <option name="updatedContent" value="from mesa import Model&#10;from importlib import import_module&#10;&#10;# Resolve RandomActivation across Mesa versions with a minimal fallback&#10;&#10;def _resolve_random_activation():&#10;    candidates = [&#10;        (&quot;mesa.time&quot;, &quot;RandomActivation&quot;),      # Mesa &lt;= 2.x&#10;        (&quot;mesa.scheduler&quot;, &quot;RandomActivation&quot;), # Mesa 3.x&#10;        (&quot;mesa.timekeeping&quot;, &quot;RandomActivation&quot;),&#10;    ]&#10;    for mod_name, attr in candidates:&#10;        try:&#10;            mod = import_module(mod_name)&#10;            ra = getattr(mod, attr)&#10;            return ra&#10;        except Exception:&#10;            continue&#10;&#10;    # Fallback scheduler&#10;    import random as _random&#10;&#10;    class _RandomActivationFallback:  # type: ignore&#10;        def __init__(self, model):&#10;            self.model = model&#10;            self._agents = []&#10;&#10;        @property&#10;        def agents(self):&#10;            return list(self._agents)&#10;&#10;        def add(self, agent):&#10;            self._agents.append(agent)&#10;&#10;        def step(self):&#10;            _random.shuffle(self._agents)&#10;            for a in list(self._agents):&#10;                a.step()&#10;&#10;    return _RandomActivationFallback&#10;&#10;_RandomActivation = _resolve_random_activation()&#10;&#10;from .ontology import onto, create_sample_data, list_inventory, _first, run_reasoner_safe, list_purchases, LOW_STOCK_RULE_ENABLED&#10;from .agents import BookAgent, CustomerAgent, EmployeeAgent&#10;from .message_bus import MessageBus&#10;&#10;&#10;class LibraryModel(Model):&#10;    def __init__(self, restock_threshold=1, restock_amount=3):&#10;        super().__init__()&#10;        self.schedule = _RandomActivation(self)&#10;        self.current_step = 0&#10;        self.restock_threshold = restock_threshold&#10;        self.restock_amount = restock_amount&#10;        self.message_bus = MessageBus()&#10;        # UI event sink for Streamlit: agents append dict events here&#10;        self.ui_events: list[dict] = []&#10;&#10;        create_sample_data()&#10;&#10;        # Ensure each book has a restock threshold set (use model default if missing)&#10;        for b in onto.Book.instances():&#10;            if _first(b.restockThreshold, None) is None:&#10;                b.restockThreshold = self.restock_threshold&#10;&#10;        uid = 0&#10;        for b in onto.Book.instances():&#10;            self.schedule.add(BookAgent(uid, self, b)); uid += 1&#10;        for c in onto.Customer.instances():&#10;            self.schedule.add(CustomerAgent(uid, self, c)); uid += 1&#10;        for e in onto.Employee.instances():&#10;            # Pass configured restock amount&#10;            self.schedule.add(EmployeeAgent(uid, self, e, restock_amount=self.restock_amount)); uid += 1&#10;&#10;    def step(self):&#10;        self.schedule.step()&#10;        self.current_step += 1&#10;&#10;    def run(self, steps=5):&#10;        print(&quot;Initial inventory:&quot;)&#10;        list_inventory()&#10;&#10;        for i in range(steps):&#10;            print(f&quot;\n--- Simulation step {i+1} ---&quot;)&#10;            self.step()&#10;&#10;        print(&quot;\nFinal inventory:&quot;)&#10;        list_inventory()&#10;&#10;        # Optional: run reasoner to apply SWRL rules&#10;        run_reasoner_safe()&#10;&#10;        # Summary of purchases (explicit + inferred)&#10;        print(&quot;\nPurchase summary:&quot;)&#10;        list_purchases()&#10;&#10;        # SWRL low-stock classification (if reasoner available) with Python fallback&#10;        titles_swrl = []&#10;        try:&#10;            titles_swrl = [ _first(b.hasTitle, b.name) for b in onto.LowStockBook.instances() ]&#10;        except Exception:&#10;            titles_swrl = []&#10;&#10;        if titles_swrl:&#10;            print(f&quot;Low-stock classification (SWRL): {titles_swrl}&quot;)&#10;        else:&#10;            # Fallback classification based on numeric comparison&#10;            fallback = []&#10;            for b in onto.Book.instances():&#10;                q = int(_first(b.availableQuantity, 0) or 0)&#10;                t = int(_first(b.restockThreshold, self.restock_threshold) or self.restock_threshold)&#10;                if q &lt; t:&#10;                    fallback.append(_first(b.hasTitle, b.name))&#10;            print(f&quot;Low-stock classification (fallback): {fallback}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/streamlit_app.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/streamlit_app.py" />
              <option name="originalContent" value="import streamlit as st&#10;import io, csv&#10;import pandas as pd&#10;import altair as alt&#10;from bookstore_mas.model import LibraryModel&#10;from bookstore_mas.ontology import onto, _first, reset_ontology, run_reasoner_safe&#10;&#10;# ----- Helpers -----&#10;&#10;def inventory_rows():&#10;    rows = []&#10;    for b in onto.Book.instances():&#10;        rows.append({&#10;            &quot;Title&quot;: _first(b.hasTitle, b.name),&#10;            &quot;Author&quot;: _first(b.hasAuthor, &quot;&quot;),&#10;            &quot;Genre&quot;: _first(b.hasGenre, &quot;&quot;),&#10;            &quot;Qty&quot;: int(_first(b.availableQuantity, 0) or 0),&#10;            &quot;Price&quot;: float(_first(b.hasPrice, 0) or 0),&#10;            &quot;Threshold&quot;: int(_first(b.restockThreshold, 0) or 0),&#10;        })&#10;    return rows&#10;&#10;&#10;def orders_rows():&#10;    rows = []&#10;    for o in onto.Order.instances():&#10;        rows.append({&#10;            &quot;Order ID&quot;: o.name,&#10;            &quot;Buyer&quot;: _first(_first(o.hasBuyer).hasName, _first(o.hasBuyer).name) if _first(o.hasBuyer) else &quot;&quot;,&#10;            &quot;Item&quot;: _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;,&#10;            &quot;Qty&quot;: int(_first(o.hasQuantity, 0) or 0),&#10;            &quot;Unit Price&quot;: float(_first(o.hasUnitPrice, 0) or 0),&#10;            &quot;Time&quot;: str(_first(o.orderTime, &quot;&quot;)),&#10;        })&#10;    return rows&#10;&#10;&#10;def low_stock_fallback(restock_default: int):&#10;    lows = []&#10;    for b in onto.Book.instances():&#10;        q = int(_first(b.availableQuantity, 0) or 0)&#10;        t = int(_first(b.restockThreshold, restock_default) or restock_default)&#10;        if q &lt; t:&#10;            lows.append(_first(b.hasTitle, b.name))&#10;    return lows&#10;&#10;&#10;def record_histories():&#10;    &quot;&quot;&quot;Record inventory quantities and new purchases for the current step.&quot;&quot;&quot;&#10;    step = st.session_state.model.current_step&#10;    # Inventory history per book&#10;    for b in onto.Book.instances():&#10;        st.session_state.inv_history.append({&#10;            &quot;step&quot;: step,&#10;            &quot;Title&quot;: _first(b.hasTitle, b.name),&#10;            &quot;Qty&quot;: int(_first(b.availableQuantity, 0) or 0),&#10;        })&#10;    # New orders detected in this step&#10;    current_ids = {o.name for o in onto.Order.instances()}&#10;    new_ids = current_ids - st.session_state.last_order_ids&#10;    if new_ids:&#10;        counts = {}&#10;        for oid in new_ids:&#10;            o = onto.search_one(iri=f&quot;*{oid}&quot;) or next((x for x in onto.Order.instances() if x.name == oid), None)&#10;            if not o:  # safety&#10;                continue&#10;            title = _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;&#10;            counts[title] = counts.get(title, 0) + int(_first(o.hasQuantity, 0) or 0)&#10;        for title, cnt in counts.items():&#10;            st.session_state.purchases_history.append({&#10;                &quot;step&quot;: step,&#10;                &quot;Title&quot;: title,&#10;                &quot;Count&quot;: cnt,&#10;            })&#10;    st.session_state.last_order_ids = current_ids&#10;&#10;&#10;# ----- App state -----&#10;&#10;if &quot;restock_threshold&quot; not in st.session_state:&#10;    st.session_state.restock_threshold = 1&#10;if &quot;restock_amount&quot; not in st.session_state:&#10;    st.session_state.restock_amount = 3&#10;if &quot;model&quot; not in st.session_state:&#10;    reset_ontology()&#10;    st.session_state.model = LibraryModel(&#10;        restock_threshold=st.session_state.restock_threshold,&#10;        restock_amount=st.session_state.restock_amount,&#10;    )&#10;    st.session_state.steps = 0&#10;    st.session_state.inv_history = []&#10;    st.session_state.purchases_history = []&#10;    st.session_state.last_order_ids = set()&#10;&#10;# ----- UI -----&#10;&#10;st.set_page_config(page_title=&quot;Bookstore MAS&quot;, layout=&quot;wide&quot;)&#10;st.title(&quot;Bookstore Management System - MAS + Ontology&quot;)&#10;&#10;with st.sidebar:&#10;    st.header(&quot;Controls&quot;)&#10;    rt = st.number_input(&quot;Restock threshold&quot;, min_value=0, max_value=100, value=st.session_state.restock_threshold, step=1)&#10;    ra = st.number_input(&quot;Restock amount&quot;, min_value=0, max_value=100, value=st.session_state.restock_amount, step=1)&#10;    apply = st.button(&quot;Apply settings (reset)&quot;)&#10;    if apply:&#10;        st.session_state.restock_threshold = int(rt)&#10;        st.session_state.restock_amount = int(ra)&#10;        reset_ontology()&#10;        st.session_state.model = LibraryModel(&#10;            restock_threshold=st.session_state.restock_threshold,&#10;            restock_amount=st.session_state.restock_amount,&#10;        )&#10;        st.session_state.steps = 0&#10;        st.session_state.inv_history = []&#10;        st.session_state.purchases_history = []&#10;        st.session_state.last_order_ids = set()&#10;        st.success(&quot;Simulation reset with new settings.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    step_once = st.button(&quot;Step once&quot;)&#10;    step_n = st.number_input(&quot;Run N steps&quot;, min_value=1, max_value=1000, value=10, step=1)&#10;    run_n = st.button(&quot;Run N steps ▶&quot;)&#10;    st.markdown(&quot;---&quot;)&#10;    if st.button(&quot;Run reasoner (SWRL)&quot;):&#10;        run_reasoner_safe()&#10;        st.toast(&quot;Reasoner executed (see terminal logs for details)&quot;)&#10;&#10;# Step controls&#10;if step_once:&#10;    st.session_state.model.step()&#10;    st.session_state.steps += 1&#10;    record_histories()&#10;if run_n:&#10;    for _ in range(int(step_n)):&#10;        st.session_state.model.step()&#10;        st.session_state.steps += 1&#10;        record_histories()&#10;&#10;# Summary metrics&#10;col1, col2, col3 = st.columns(3)&#10;col1.metric(&quot;Steps&quot;, st.session_state.steps)&#10;col2.metric(&quot;Current step (model)&quot;, st.session_state.model.current_step)&#10;col3.metric(&quot;Restock threshold&quot;, st.session_state.restock_threshold)&#10;&#10;# Data + Exports&#10;left, right = st.columns(2)&#10;with left:&#10;    st.subheader(&quot;Inventory&quot;)&#10;    inv_df = pd.DataFrame(inventory_rows())&#10;    st.dataframe(inv_df, use_container_width=True)&#10;    # Export inventory CSV&#10;    inv_buf = io.StringIO()&#10;    writer = csv.DictWriter(inv_buf, fieldnames=list(inv_df.columns))&#10;    writer.writeheader()&#10;    for row in inv_df.to_dict(orient=&quot;records&quot;):&#10;        writer.writerow(row)&#10;    st.download_button(&#10;        label=&quot;Download Inventory CSV&quot;,&#10;        data=inv_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;inventory.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;    lows = low_stock_fallback(st.session_state.restock_threshold)&#10;    st.caption(f&quot;Low-stock (fallback): {lows if lows else 'None'}&quot;)&#10;&#10;with right:&#10;    st.subheader(&quot;Orders&quot;)&#10;    orders_df = pd.DataFrame(orders_rows())&#10;    st.dataframe(orders_df, use_container_width=True)&#10;    # Export orders CSV&#10;    ord_buf = io.StringIO()&#10;    if not orders_df.empty:&#10;        writer = csv.DictWriter(ord_buf, fieldnames=list(orders_df.columns))&#10;        writer.writeheader()&#10;        for row in orders_df.to_dict(orient=&quot;records&quot;):&#10;            writer.writerow(row)&#10;    else:&#10;        ord_buf.write(&quot;Order ID,Buyer,Item,Qty,Unit Price,Time\n&quot;)&#10;    st.download_button(&#10;        label=&quot;Download Orders CSV&quot;,&#10;        data=ord_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;orders.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;&#10;# Charts&#10;st.subheader(&quot;Charts&quot;)&#10;chart_left, chart_right = st.columns(2)&#10;with chart_left:&#10;    st.caption(&quot;Current stock&quot;)&#10;    if not inv_df.empty:&#10;        bar = alt.Chart(inv_df).mark_bar().encode(&#10;            x=alt.X(&quot;Title:N&quot;, sort=None),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;Title:N&quot;, legend=None),&#10;            tooltip=list(inv_df.columns),&#10;        )&#10;        st.altair_chart(bar, use_container_width=True)&#10;    else:&#10;        st.info(&quot;No inventory to chart.&quot;)&#10;&#10;with chart_right:&#10;    st.caption(&quot;Inventory over steps&quot;)&#10;    inv_hist_df = pd.DataFrame(st.session_state.get(&quot;inv_history&quot;, []))&#10;    if not inv_hist_df.empty:&#10;        line = alt.Chart(inv_hist_df).mark_line(point=True).encode(&#10;            x=alt.X(&quot;step:Q&quot;),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;Title:N&quot;),&#10;            tooltip=[&quot;step:Q&quot;, &quot;Title:N&quot;, &quot;Qty:Q&quot;],&#10;        )&#10;        st.altair_chart(line, use_container_width=True)&#10;    else:&#10;        st.info(&quot;Step the simulation to build the time series.&quot;)&#10;&#10;st.subheader(&quot;Purchases over time&quot;)&#10;p_hist_df = pd.DataFrame(st.session_state.get(&quot;purchases_history&quot;, []))&#10;if not p_hist_df.empty:&#10;    bars = alt.Chart(p_hist_df).mark_bar().encode(&#10;        x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;        y=alt.Y(&quot;Count:Q&quot;, title=&quot;Purchases&quot;),&#10;        color=alt.Color(&quot;Title:N&quot;, title=&quot;Book&quot;),&#10;        tooltip=[&quot;step:Q&quot;, &quot;Title:N&quot;, &quot;Count:Q&quot;],&#10;    )&#10;    st.altair_chart(bars, use_container_width=True)&#10;else:&#10;    st.info(&quot;No purchases recorded yet. Step the simulation to generate data.&quot;)&#10;&#10;# Purchases summary&#10;st.subheader(&quot;Purchases by customer&quot;)&#10;rows = []&#10;for c in onto.Customer.instances():&#10;    rows.append({&#10;        &quot;Customer&quot;: _first(c.hasName, c.name),&#10;        &quot;Purchases&quot;: &quot;, &quot;.join(_first(b.hasTitle, b.name) for b in (c.purchases or [])),&#10;    })&#10;st.table(rows)&#10;&#10;st.caption(&quot;Tip: Use the sidebar to step or run multiple steps, adjust thresholds, and reset the simulation.&quot;)&#10;" />
              <option name="updatedContent" value="import streamlit as st&#10;import io, csv&#10;import pandas as pd&#10;import altair as alt&#10;from bookstore_mas.model import LibraryModel&#10;from bookstore_mas.ontology import onto, _first, reset_ontology, run_reasoner_safe&#10;&#10;# ----- Helpers -----&#10;&#10;def inventory_rows():&#10;    rows = []&#10;    for b in onto.Book.instances():&#10;        title = _first(b.hasTitle, b.name)&#10;        qty = int(_first(b.availableQuantity, 0) or 0)&#10;        thr = int(_first(b.restockThreshold, 0) or 0)&#10;        if qty &lt; thr:&#10;            state = &quot;Low&quot;&#10;        elif qty == thr:&#10;            state = &quot;At threshold&quot;&#10;        else:&#10;            state = &quot;OK&quot;&#10;        rows.append({&#10;            &quot;Title&quot;: title,&#10;            &quot;Author&quot;: _first(b.hasAuthor, &quot;&quot;),&#10;            &quot;Genre&quot;: _first(b.hasGenre, &quot;&quot;),&#10;            &quot;Qty&quot;: qty,&#10;            &quot;Threshold&quot;: thr,&#10;            &quot;State&quot;: state,&#10;            &quot;Price&quot;: float(_first(b.hasPrice, 0) or 0),&#10;        })&#10;    return rows&#10;&#10;&#10;def orders_rows():&#10;    rows = []&#10;    for o in onto.Order.instances():&#10;        rows.append({&#10;            &quot;Order ID&quot;: o.name,&#10;            &quot;Buyer&quot;: _first(_first(o.hasBuyer).hasName, _first(o.hasBuyer).name) if _first(o.hasBuyer) else &quot;&quot;,&#10;            &quot;Item&quot;: _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;,&#10;            &quot;Qty&quot;: int(_first(o.hasQuantity, 0) or 0),&#10;            &quot;Unit Price&quot;: float(_first(o.hasUnitPrice, 0) or 0),&#10;            &quot;Time&quot;: str(_first(o.orderTime, &quot;&quot;)),&#10;        })&#10;    return rows&#10;&#10;&#10;def low_stock_fallback(restock_default: int):&#10;    lows = []&#10;    for b in onto.Book.instances():&#10;        q = int(_first(b.availableQuantity, 0) or 0)&#10;        t = int(_first(b.restockThreshold, restock_default) or restock_default)&#10;        if q &lt; t:&#10;            lows.append(_first(b.hasTitle, b.name))&#10;    return lows&#10;&#10;&#10;def record_histories():&#10;    &quot;&quot;&quot;Record inventory quantities, thresholds, new purchases, and new UI events for the current step.&quot;&quot;&quot;&#10;    step = st.session_state.model.current_step&#10;    # Inventory history per book&#10;    for b in onto.Book.instances():&#10;        st.session_state.inv_history.append({&#10;            &quot;step&quot;: step,&#10;            &quot;Title&quot;: _first(b.hasTitle, b.name),&#10;            &quot;Qty&quot;: int(_first(b.availableQuantity, 0) or 0),&#10;            &quot;Threshold&quot;: int(_first(b.restockThreshold, st.session_state.restock_threshold) or st.session_state.restock_threshold),&#10;        })&#10;    # New orders detected in this step&#10;    current_ids = {o.name for o in onto.Order.instances()}&#10;    new_ids = current_ids - st.session_state.last_order_ids&#10;    if new_ids:&#10;        counts = {}&#10;        for oid in new_ids:&#10;            o = onto.search_one(iri=f&quot;*{oid}&quot;) or next((x for x in onto.Order.instances() if x.name == oid), None)&#10;            if not o:  # safety&#10;                continue&#10;            title = _first(_first(o.hasItem).hasTitle, _first(o.hasItem).name) if _first(o.hasItem) else &quot;&quot;&#10;            counts[title] = counts.get(title, 0) + int(_first(o.hasQuantity, 0) or 0)&#10;        for title, cnt in counts.items():&#10;            st.session_state.purchases_history.append({&#10;                &quot;step&quot;: step,&#10;                &quot;Title&quot;: title,&#10;                &quot;Count&quot;: cnt,&#10;            })&#10;    st.session_state.last_order_ids = current_ids&#10;    # Capture new UI events from the model&#10;    evts = st.session_state.model.ui_events&#10;    new_events = evts[st.session_state.events_seen:]&#10;    st.session_state.events_seen = len(evts)&#10;    if new_events:&#10;        st.session_state.event_feed.extend(new_events)&#10;&#10;&#10;def event_badge(evt_type: str) -&gt; str:&#10;    colors = {&#10;        &quot;purchase&quot;: &quot;#2563eb&quot;,        # blue&#10;        &quot;low_stock_trigger&quot;: &quot;#f59e0b&quot;, # amber&#10;        &quot;restock&quot;: &quot;#16a34a&quot;,         # green&#10;        &quot;out_of_stock&quot;: &quot;#dc2626&quot;,    # red&#10;    }&#10;    label = {&#10;        &quot;purchase&quot;: &quot;Purchase&quot;,&#10;        &quot;low_stock_trigger&quot;: &quot;Low stock&quot;,&#10;        &quot;restock&quot;: &quot;Restock&quot;,&#10;        &quot;out_of_stock&quot;: &quot;Out of stock&quot;,&#10;    }.get(evt_type, evt_type)&#10;    color = colors.get(evt_type, &quot;#6b7280&quot;)&#10;    return f'&lt;span style=&quot;background:{color};color:white;padding:2px 8px;border-radius:999px;font-size:12px;&quot;&gt;{label}&lt;/span&gt;'&#10;&#10;&#10;def render_event(evt: dict) -&gt; str:&#10;    t = evt.get(&quot;type&quot;)&#10;    step = evt.get(&quot;step&quot;)&#10;    badge = event_badge(t)&#10;    if t == &quot;purchase&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('customer')} bought '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' (qty {evt.get('qty_before')}→{evt.get('qty_after')}, thr {evt.get('threshold')})&quot;&#10;    if t == &quot;low_stock_trigger&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' fell below threshold (qty {evt.get('qty')}, thr {evt.get('threshold')}) — restock requested&quot;&#10;    if t == &quot;restock&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('employee')} restocked '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' (+{evt.get('added')}, {evt.get('qty_before')}→{evt.get('qty_after')})&quot;&#10;    if t == &quot;out_of_stock&quot;:&#10;        return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;: {evt.get('customer')} tried to buy '&lt;b&gt;{evt.get('book')}&lt;/b&gt;' but stock was {evt.get('qty')}&quot;&#10;    return f&quot;{badge} &lt;b&gt;Step {step}&lt;/b&gt;&quot;&#10;&#10;&#10;# ----- App state -----&#10;&#10;if &quot;restock_threshold&quot; not in st.session_state:&#10;    st.session_state.restock_threshold = 1&#10;if &quot;restock_amount&quot; not in st.session_state:&#10;    st.session_state.restock_amount = 3&#10;if &quot;model&quot; not in st.session_state:&#10;    reset_ontology()&#10;    st.session_state.model = LibraryModel(&#10;        restock_threshold=st.session_state.restock_threshold,&#10;        restock_amount=st.session_state.restock_amount,&#10;    )&#10;    st.session_state.steps = 0&#10;    st.session_state.inv_history = []&#10;    st.session_state.purchases_history = []&#10;    st.session_state.last_order_ids = set()&#10;    st.session_state.event_feed = []&#10;    st.session_state.events_seen = 0&#10;&#10;# ----- UI -----&#10;&#10;st.set_page_config(page_title=&quot;Bookstore MAS&quot;, layout=&quot;wide&quot;)&#10;st.title(&quot;Bookstore Management System - MAS + Ontology&quot;)&#10;&#10;with st.sidebar:&#10;    st.header(&quot;Controls&quot;)&#10;    rt = st.number_input(&quot;Restock threshold&quot;, min_value=0, max_value=100, value=st.session_state.restock_threshold, step=1)&#10;    ra = st.number_input(&quot;Restock amount&quot;, min_value=0, max_value=100, value=st.session_state.restock_amount, step=1)&#10;    apply = st.button(&quot;Apply settings (reset)&quot;)&#10;    if apply:&#10;        st.session_state.restock_threshold = int(rt)&#10;        st.session_state.restock_amount = int(ra)&#10;        reset_ontology()&#10;        st.session_state.model = LibraryModel(&#10;            restock_threshold=st.session_state.restock_threshold,&#10;            restock_amount=st.session_state.restock_amount,&#10;        )&#10;        st.session_state.steps = 0&#10;        st.session_state.inv_history = []&#10;        st.session_state.purchases_history = []&#10;        st.session_state.last_order_ids = set()&#10;        st.session_state.event_feed = []&#10;        st.session_state.events_seen = 0&#10;        st.success(&quot;Simulation reset with new settings.&quot;)&#10;&#10;    st.markdown(&quot;---&quot;)&#10;    step_once = st.button(&quot;Step once&quot;)&#10;    step_n = st.number_input(&quot;Run N steps&quot;, min_value=1, max_value=1000, value=10, step=1)&#10;    run_n = st.button(&quot;Run N steps ▶&quot;)&#10;    st.markdown(&quot;---&quot;)&#10;    if st.button(&quot;Run reasoner (SWRL)&quot;):&#10;        run_reasoner_safe()&#10;        st.toast(&quot;Reasoner executed (see terminal logs for details)&quot;)&#10;&#10;# Step controls&#10;if step_once:&#10;    st.session_state.model.step()&#10;    st.session_state.steps += 1&#10;    record_histories()&#10;if run_n:&#10;    for _ in range(int(step_n)):&#10;        st.session_state.model.step()&#10;        st.session_state.steps += 1&#10;        record_histories()&#10;&#10;# Summary metrics&#10;col1, col2, col3 = st.columns(3)&#10;col1.metric(&quot;Steps&quot;, st.session_state.steps)&#10;col2.metric(&quot;Current step (model)&quot;, st.session_state.model.current_step)&#10;col3.metric(&quot;Restock threshold&quot;, st.session_state.restock_threshold)&#10;&#10;# Data + Exports&#10;left, right = st.columns(2)&#10;with left:&#10;    st.subheader(&quot;Inventory&quot;)&#10;    inv_df = pd.DataFrame(inventory_rows())&#10;    st.dataframe(inv_df, use_container_width=True)&#10;    # Export inventory CSV&#10;    inv_buf = io.StringIO()&#10;    writer = csv.DictWriter(inv_buf, fieldnames=list(inv_df.columns))&#10;    writer.writeheader()&#10;    for row in inv_df.to_dict(orient=&quot;records&quot;):&#10;        writer.writerow(row)&#10;    st.download_button(&#10;        label=&quot;Download Inventory CSV&quot;,&#10;        data=inv_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;inventory.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;    lows = low_stock_fallback(st.session_state.restock_threshold)&#10;    st.caption(f&quot;Low-stock (fallback): {lows if lows else 'None'}&quot;)&#10;&#10;with right:&#10;    st.subheader(&quot;Orders&quot;)&#10;    orders_df = pd.DataFrame(orders_rows())&#10;    st.dataframe(orders_df, use_container_width=True)&#10;    # Export orders CSV&#10;    ord_buf = io.StringIO()&#10;    if not orders_df.empty:&#10;        writer = csv.DictWriter(ord_buf, fieldnames=list(orders_df.columns))&#10;        writer.writeheader()&#10;        for row in orders_df.to_dict(orient=&quot;records&quot;):&#10;            writer.writerow(row)&#10;    else:&#10;        ord_buf.write(&quot;Order ID,Buyer,Item,Qty,Unit Price,Time\n&quot;)&#10;    st.download_button(&#10;        label=&quot;Download Orders CSV&quot;,&#10;        data=ord_buf.getvalue().encode(&quot;utf-8&quot;),&#10;        file_name=&quot;orders.csv&quot;,&#10;        mime=&quot;text/csv&quot;,&#10;    )&#10;&#10;# Charts&#10;st.subheader(&quot;Charts&quot;)&#10;chart_left, chart_right = st.columns(2)&#10;with chart_left:&#10;    st.caption(&quot;Current stock vs threshold&quot;)&#10;    if not inv_df.empty:&#10;        inv_df_chart = inv_df.copy()&#10;        def state_color(state: str) -&gt; str:&#10;            return {&quot;Low&quot;: &quot;#dc2626&quot;, &quot;At threshold&quot;: &quot;#f59e0b&quot;, &quot;OK&quot;: &quot;#16a34a&quot;}.get(state, &quot;#6b7280&quot;)&#10;        inv_df_chart[&quot;Color&quot;] = inv_df_chart[&quot;State&quot;].map(state_color)&#10;        bar = alt.Chart(inv_df_chart).mark_bar().encode(&#10;            x=alt.X(&quot;Title:N&quot;, sort=None),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;State:N&quot;, scale=alt.Scale(domain=[&quot;Low&quot;,&quot;At threshold&quot;,&quot;OK&quot;], range=[&quot;#dc2626&quot;,&quot;#f59e0b&quot;,&quot;#16a34a&quot;])),&#10;            tooltip=[&quot;Title&quot;,&quot;Qty&quot;,&quot;Threshold&quot;,&quot;State&quot;,&quot;Price&quot;],&#10;        )&#10;        # Threshold rule per bar is not trivial; show as points overlayed for clarity&#10;        thr_points = alt.Chart(inv_df_chart).mark_point(shape=&quot;triangle-down&quot;, size=120, color=&quot;#f59e0b&quot;).encode(&#10;            x=alt.X(&quot;Title:N&quot;), y=alt.Y(&quot;Threshold:Q&quot;), tooltip=[&quot;Title&quot;,&quot;Threshold&quot;],&#10;        )&#10;        st.altair_chart((bar + thr_points), use_container_width=True)&#10;    else:&#10;        st.info(&quot;No inventory to chart.&quot;)&#10;&#10;with chart_right:&#10;    st.caption(&quot;Inventory over steps vs threshold&quot;)&#10;    inv_hist_df = pd.DataFrame(st.session_state.get(&quot;inv_history&quot;, []))&#10;    if not inv_hist_df.empty:&#10;        qty_line = alt.Chart(inv_hist_df).mark_line(point=True, color=&quot;#2563eb&quot;).encode(&#10;            x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;            y=alt.Y(&quot;Qty:Q&quot;),&#10;            color=alt.Color(&quot;Title:N&quot;, legend=alt.Legend(title=&quot;Book&quot;)),&#10;            tooltip=[&quot;step:Q&quot;,&quot;Title:N&quot;,&quot;Qty:Q&quot;,&quot;Threshold:Q&quot;],&#10;        )&#10;        thr_line = alt.Chart(inv_hist_df).mark_line(strokeDash=[6,4], color=&quot;#f59e0b&quot;).encode(&#10;            x=alt.X(&quot;step:Q&quot;), y=alt.Y(&quot;Threshold:Q&quot;), color=alt.Color(&quot;Title:N&quot;, legend=None),&#10;        )&#10;        st.altair_chart(qty_line + thr_line, use_container_width=True)&#10;    else:&#10;        st.info(&quot;Step the simulation to build the time series.&quot;)&#10;&#10;st.subheader(&quot;Purchases over time&quot;)&#10;p_hist_df = pd.DataFrame(st.session_state.get(&quot;purchases_history&quot;, []))&#10;if not p_hist_df.empty:&#10;    bars = alt.Chart(p_hist_df).mark_bar().encode(&#10;        x=alt.X(&quot;step:Q&quot;, title=&quot;Step&quot;),&#10;        y=alt.Y(&quot;Count:Q&quot;, title=&quot;Purchases&quot;),&#10;        color=alt.Color(&quot;Title:N&quot;, title=&quot;Book&quot;),&#10;        tooltip=[&quot;step:Q&quot;, &quot;Title:N&quot;, &quot;Count:Q&quot;],&#10;    )&#10;    st.altair_chart(bars, use_container_width=True)&#10;else:&#10;    st.info(&quot;No purchases recorded yet. Step the simulation to generate data.&quot;)&#10;&#10;# Purchases summary&#10;st.subheader(&quot;Purchases by customer&quot;)&#10;rows = []&#10;for c in onto.Customer.instances():&#10;    rows.append({&#10;        &quot;Customer&quot;: _first(c.hasName, c.name),&#10;        &quot;Purchases&quot;: &quot;, &quot;.join(_first(b.hasTitle, b.name) for b in (c.purchases or [])),&#10;    })&#10;st.table(rows)&#10;&#10;# Event timeline&#10;st.subheader(&quot;Event timeline&quot;)&#10;with st.container(border=True):&#10;    if st.session_state.event_feed:&#10;        for evt in reversed(st.session_state.event_feed[-30:]):  # show last 30 events&#10;            st.markdown(render_event(evt), unsafe_allow_html=True)&#10;    else:&#10;        st.info(&quot;No events yet. Step the simulation to see purchases, low-stock triggers, and restocks.&quot;)&#10;&#10;# Legend&#10;with st.expander(&quot;Legend: colors and thresholds&quot;):&#10;    st.markdown(&#10;        &quot;- State colors: &lt;span style='color:#16a34a;'&gt;OK&lt;/span&gt;, &lt;span style='color:#f59e0b;'&gt;At threshold&lt;/span&gt;, &lt;span style='color:#dc2626;'&gt;Low&lt;/span&gt;&lt;br&gt;&quot;&#10;        &quot;- Bars show current quantity; orange triangles mark each title's threshold.&lt;br&gt;&quot;&#10;        &quot;- Time series: blue line = quantity, orange dashed = threshold.&lt;br&gt;&quot;&#10;        &quot;- Event badges: blue=purchase, orange=low stock trigger, green=restock, red=out-of-stock.&quot;,&#10;        unsafe_allow_html=True,&#10;    )&#10;&#10;st.caption(&quot;Tip: Use the sidebar to step or run multiple steps, adjust thresholds, and reset the simulation. Colors and badges highlight threshold-driven behavior in real time.&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>